Шпаргалка по консольным командам Git
Общее
Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). Важно: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

Ключ к пониманию
Ключ к пониманию концепции git — знание о «трех деревьях»:

Рабочая директория — файловая система проекта (те файлы, с которыми вы работаете).
Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).
Директория .git/ — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).
Коммит — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.

Простейший цикл работ
Редактирование, добавление, удаление файлов (собственно, работа).
Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
Коммит (фиксация изменений).
Возврат к шагу 1 или отход ко сну.
Указатели
HEAD — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
ORIG_HEAD — указатель на коммит, с которого вы только что переместили HEAD (командой git reset ..., например).
Ветка (master, develop etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
Теги — простые указатели на коммиты. Не перемещаются.
Настройки
Перед началом работы нужно выполнить некоторые настройки:

git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты
git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера
Если вы в Windows:

git config --global core.autocrlf true # включить преобразование окончаний строк из CRLF в LF
Указание неотслеживаемых файлов
Файлы и директории, которые не нужно включать в репозиторий, указываются в файле .gitignore. Обычно это устанавливаемые зависимости (node_modules/, bower_components/), готовая сборка build/ или dist/ и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, возможно использование шаблонов.

Консоль
Как использовать консоль Bash в Windows, основные команды.

Длинный вывод в консоли: Vim
Вызов некоторых консольных команд приводит к необходимости очень длинного вывода в консоль (пример: вывод истории всех изменений в файле командой git log -p fileName.txt). При этом прямо в консоли запускается редактор Vim. Он работает в нескольких режимах, из которых Вас заинтересуют режим вставки (редактирование текста) и нормальный (командный) режим. Чтобы попасть из Vim обратно в консоль, нужно в командном режиме ввести :q. Переход в командный режим из любого другого: Esc.

Если нужно что-то написать, нажмите i — это переход в режим вставки текста. Если нужно сохранить изменения, перейдите в командный режим и наберите :w.

Vim (некоторые команды)
# Нажатия кнопок
ESC     — переход в командный режим
i       — переход в режим редактирования текста
ZQ (зажат Shift, поочередное нажатие) — выход без сохранения
ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти
```bash
# Нажатия кнопок
ESC     — переход в командный режим
i       — переход в режим редактирования текста
ZQ (зажат Shift, поочередное нажатие) — выход без сохранения
ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти

# Ввод в командном режиме
:q!             — выйти без сохранения
:wq             — сохранить файл и выйти
:w filename.txt — сохранить файл как filename.txt
Консольные команды
Создать новый репозиторий
git init             # создать новый проект в текущей директории
git init folder-name # создать новый проект в указанной директории
Клонирование репозитория
# клонировать удаленный репозиторий в одноименную директорию
git clone https://github.com/cyberspacedk/Git-commands.git    

# клонировать удаленный репозиторий в директорию «FolderName»
git clone https://github.com/cyberspacedk/Git-commands.git FolderName 

# клонировать репозиторий в текущую директорию
git clone https://github.com:nicothin/web-design.git .           
Просмотр изменений
git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)
git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff index.html     # сравнить файл из рабочей директории и индекс
git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --staged       # сравнить индекс и коммит с HEAD
git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master
git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов
git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master
Добавление изменений в индекс
git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)
git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов
git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании
Удаление изменений из индекса
git reset            # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add
git reset readme.txt # убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)
Отмена изменений
git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
git clean -df              # удалить неотслеживаемые файлы и директории
Коммиты
git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение
git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение
Отмена коммитов и перемещение по истории
Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (git revert), дабы избежать проблем с историей разработки у других участников проекта.

git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения
git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)
Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.

# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)
git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита
git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения
git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад
git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)
# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории
git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)
Временно переключиться на другой коммит
git checkout b9533bb # переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)
git checkout master  # переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)
Переключиться на другой коммит и продолжить работу с него
Потребуется создание новой ветки, начинающейся с указанного коммита.

git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)
Восстановление изменений
git checkout 5589877 index.html  # восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)
Копирование коммита (перенос коммитов)
git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения
git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)
git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт
git cherry-pick --abort    # прервать конфликтный перенос коммитов
git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)
Удаление файла
git rm text.txt    # удалить отслеживаемый неизменённый файл и проиндексировать это изменение
git rm -f text.txt # удалить отслеживаемый изменённый файл и проиндексировать это изменение
git rm -r log/     # удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
git rm ind*        # удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
git rm --cached readme.txt # удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)
Перемещение/переименование файлов
Для git не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определен только после индексации изменения.

git mv text.txt test_new.txt # переименовать файл «text.txt» в «test_new.txt» и проиндексировать это изменение
git mv readme_new.md folder/ # переместить файл readme_new.md в директорию folder/ (должна существовать) и проиндексировать это изменение
История коммитов
Выход из длинного лога вывода: q.

git log master             # показать коммиты в указанной ветке
git log -2                 # показать последние 2 коммита в активной ветке
git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений
git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк
git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления
git log --since=2.weeks    # показать коммиты за последние 2 недели
git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты
git log index.html         # показать историю изменений файла index.html (только коммиты)
git log -5 index.html      # показать историю изменений файла index.html, последние 5 коммитов (только коммиты)
git log -p index.html      # показать историю изменений файла index.html (коммиты и изменения)
git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)
git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле
git log --grep fix         # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)
git log --grep fix -i      # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)
git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)
git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат вывода, висящий на алиасе оболочки
git log master..branch_99  # показать коммиты из ветки branch_99, которые не влиты в master
git log branch_99..master  # показать коммиты из ветки master, которые не влиты в branch_99
git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)
git show 60d6582           # показать изменения из коммита с указанным хешем
git show HEAD~             # показать данные о предыдущем коммите в активной ветке
git show @~                # аналогично предыдущему
git show HEAD~3            # показать данные о коммите, который был 3 коммита назад
git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке
git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита
git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)
Кто написал строку
git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены
История изменений указателей (веток, HEAD)
git reflog -20             # показать последние 20 изменений положения указателя HEAD
git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий
Ветки
git branch                 # показать список веток
git branch -v              # показать список веток и последний коммит в каждой
git branch new_branch      # создать новую ветку с указанным именем на текущем коммите
git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите
git branch -f master 5589877  # переместить ветку master на указанный коммит
git branch -f master master~2 # переместить ветку master на 2 коммита назад
git checkout new_branch    # перейти в указанную ветку
git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё
git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё
git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования
Теги
git tag v1.0.0               # создать тег с указанным именем на коммите, на который указывает HEAD
git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master
git tag -d v1.0.0            # удалить тег с указанным именем(ами)
git tag -n                   # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
git tag -n -l 'v1.*'         # показать все теги, которые начинаются с 'v1.*'
Временное сохранение изменений без коммита
git stash     # временно сохранить незакоммиченные изменения и убрать их из рабочей директории
git stash pop # вернуть сохраненные командой git stash изменения в рабочую директорию
Удалённые репозитории
Есть два распространённых способа привязать удалённый репозиторий к локальному: по HTTPS и по SSH. Если SSH у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).

git remote -v              # показать список удалённых репозиториев, связанных с локальным
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)
Конфликт слияния
Предполагается ситуация: есть ветка master и есть ветка feature. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку master пытаемся влить ветку feature (git merge feature), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле index.html.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу
git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)
git reset --abort # то же, что и строкой выше
«Перенос» ветки
Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)
git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature
git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase
git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)
Как отменить rebase
git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки
git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс
Разное
git archive -o ./project.zip HEAD # создать архив с файловой структурой проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)
Примеры
Собираем коллекцию простых и сложных примеров работы.

Начало работы
Создание нового репозитория, первый коммит, привязка удалённого репозитория с gthub.com, отправка изменений в удалённый репозиторий.

# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      # создаём репозиторий в этой директории
touch readme.md               # создаем файл readme.md
git add readme.md             # добавляем файл в индекс
git commit -m "Старт"         # создаем коммит
git remote add origin https://github.com:nicothin/test.git # добавляем предварительно созданный пустой удаленный репозиторий
git push -u origin master     # отправляем данные из локального репозитория в удаленный (в ветку master)
«Внесение изменений» в коммит
Только если коммит ещё не был отправлен в удалённые репозиторий.

# указана последовательность действий:
subl inc/header.html          # редактируем и сохраняем разметку «шапки»
git add inc/header.html       # индексируем измененный файл
git commit -m "Убрал телефон из шапки" # делаем коммит
# ВНИМАНИЕ: коммит пока не был отправлен в удалённый репозиторий
# сознаём, что нужно было еще что-то сделать в этом коммите.
subl inc/header.html          # вносим изменения
git add inc/header.html       # индексируем измененный файл (можно git add .)
git commit --amend -m "«Шапка»: выполнена задача №34" # заново делаем коммит
Работа с ветками
Есть master (публичная версия сайта), выполняем масштабную задачу (переверстать «шапку»), но по ходу работ возникает необходимость подправить критичный баг (неправильно указан контакт в «подвале»).

# указана последовательность действий:
git checkout -b new-page-header # создадим новую ветку для задачи изменения «шапки» и перейдём в неё
subl inc/header.html            # редактируем разметку «шапки»
git commit -a -m "Новая шапка: смена логотипа" # делаем коммит (работа еще не завершена)
# тут выясняется, что есть баг с контактом в «подвале»
git checkout master             # возвращаемся к ветке master
subl inc/footer.html            # устраняем баг и сохраняем разметку «подвала»
git commit -a -m "Исправление контакта в подвале" # делаем коммит
git push                        # отправляем коммит с быстрым критическим изменением в master в удалённом репозитории
git checkout new-page-header    # переключаемся обратно в ветку new-page-header для продолжения работ над «шапкой»
subl inc/header.html            # редактируем и сохраняем разметку «шапки»
git commit -a -m "Новая шапка: смена навигации" # делаем коммит (работа над «шапкой» завершена)
git checkout master             # переключаемся в ветку master
git merge new-page-header       # вливаем в master изменения из ветки new-page-header
git branch -d new-page-header   # удаляем ветку new_page_header
Работа с ветками, слияние и откат к состоянию до слияния
Была ветка fix, в которой исправляли баг. Исправили, влили fix в master. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить master к состоянию без слияния (наличие бага менее критично, чем порча функциональности).

# находимся в ветке fix, баг уже «исправлен»
git checkout master            # переключаемся на master
git merge fix                  # вливаем изменения из fix в master
# видим проблему: часть функциональности сломалась
git checkout fix               # переключаемся на fix (пока мы в master, git не даст ее двигать)
git branch -f master ORIG_HEAD # передвигаем ветку master на коммит, указанный в ORIG_HEAD (тот, на который указывала master до вливания fix)
Работа с ветками, конфликт слияния
Есть ветка master (публичная версия сайта), в двух параллельных ветках (branch-1 и branch-2) было отредактировано одно и то же место одного и того же файла, первую ветку (branch-1) влили в master, попытка влить вторую вызывает конфликт.

# указана последовательность действий:
git checkout master           # переключаемся на ветку master
git checkout -b branch-1      # создаём ветку branch-1, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 1"   # коммитим
git checkout master           # возвращаемся к ветке master
git checkout -b branch-2      # создаём ветку branch-2, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 2"   # коммитим
git checkout master           # возвращаемся к ветке master
git merge branch-1            # вливаем изменения из ветки branch-1 в текущую ветку (master), удача (автослияние)
git merge branch-2            # вливаем изменения из ветки branch-2 в текущую ветку (master), КОНФЛИКТ автослияния
# Automatic merge failed; fix conflicts and then commit the result.
subl .                        # выбираем в конфликтных файлах те участки, которые нужно оставить, сохраняем
git commit -a -m "Устранение конфликта" # коммитим результат устранения конфликта
Синхронизация репозитория-форка с мастер-репозиторием
Есть некий репозиторий на github.com, он него нами был сделан форк, добавлены какие-то изменения. Оригинальный (мастер-)репозиторий был как-то обновлён. Задача: стянуть с мастер-репозитория изменения (которые там внесены уже после того, как мы его форкнули).

# указана последовательность действий:
git remote add upstream https://github.com:address.git # добавляем удаленный репозиторий: сокр. имя — upstream, URL мастер-репозитория
git fetch upstream            # стягиваем все ветки мастер-репозитория, но пока не сливаем со своими
git checkout master           # переключаемся на ветку master своего репозитория
git merge upstream/master     # вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master
Ошибка в работе: закоммитили в мастер, но поняли, что нужно было коммитить в новую ветку
ВАЖНО: это сработает только если коммит еще не отправлен в удалённый репозиторий.

# указана последовательность действий:
# сделали изменения, проиндексировали их, закоммитили в master, но ЕЩЁ НЕ ОТПРАВИЛИ (не делали git push)
git checkout -b new-branch    # создаём новую вертку из master
git checkout master           # переключаемся на master
git reset HEAD~ --hard        # сдвигаем указатель (ветку) master на 1 коммит назад
git checkout new-branch       # переключаемся обратно на новую ветку для продолжения работы
Нужно вернуть содержимое файла к состоянию, бывшему в каком-либо коммите (известен хеш коммита)
# указана последовательность действий:
git checkout f26ed88 -- index.html # восстановить в рабочей директории состояние указанного файла на момент указанного коммита, добавить это изменение в индекс
git commit -am "Navigation fixs"   # сделать коммит
При любом действии с github (или другим удалённым сервисом) запрашивается логин и пароль
Речь именно о запросе пары логин + пароль, а не ключевой фразы. Происходит это потому, что git по умолчанию не сохранит пароль для доступа к репозиторию по HTTPS.

Простое решение: указать git кешировать ваш пароль.

.gitattributes
git add *.h
git status
git commit -a -m "03-10-19"

git remote add store_1 https://github.com/AlexIvFreeworld/HW.git - подключение репозитория под именем store_1 
git push store_1 master - отправка ветки master в репозиторий под сокращ именем store_1Основы Git
Так получилось, что Git захватил лидерство среди подобных систем. В этом уроке мы рассмотрим основы работы с ним.

Устанавливается Git как и любая другая программа:

MacOS: brew install git
Ubuntu/Debian: sudo apt install git
Windows: choco install git (Chocolatey либо Git for Windows, если вы не знакомы с пакетными менеджерами)
Проверяем, что Git установился:

$ git --version
Первым делом, необходимо выполнить настройку Git. С помощью команд указанных ниже, установите имя и почту.

$ git config --global user.name "Mona Lisa"
$ git config --global user.email "mona@lisa.io"
Эти данные используются в коммитах для понимания того, кто был автором коммита.

Инициализация репозитория
Для инициализации нужно выполнить команду git init внутри той директории, которая станет репозиторием.

~$ mkdir example
# Переходим в директорию example
~$ cd example/
# Команда инициализации
example$ git init
Initialized empty Git repository in .../example/.git/
Инициализация создаёт директорию .git.

example$ ls -la
total 0
drwxr-xr-x   3 mokevnin  wheel   96 Mar  4 08:51 .
drwxrwxrwt  11 root      wheel  352 Mar  4 08:50 ..
drwxr-xr-x   9 mokevnin  wheel  288 Mar  4 08:51 .git
Внутри неё содержится конфигурация репозитория (в файле .git/config) и все изменения, которые когда-либо делались с репозиторием. Её удаление равносильно удалению репозитория. При этом код, с которым мы непосредственно работаем (то, что лежит вне .git) находится в так называемой рабочей копии. Рабочая копия называется копией не случайно. Удалив все её содержимое, мы ничего не теряем. Git всё помнит и позволяет восстановиться до исходного состояния.

Убедиться в том, что репозиторий инициализирован и находится в работоспособном состоянии можно командой git status:

example$ git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
Если выполнить команду git status вне директории содержащей .git, то Git «пожалуется» на отсутствие репозитория:

tmp$ git status
fatal: Not a git repository (or any of the parent directories): .git
Коммит
# Создаём файл
example$ touch README.md
# Меняем содержимое
example$ echo '# Hi' > README.md
# Так Git увидит новый файл
example$ git add README.md
 # Коммит с сообщением 'init project'
example$ git commit -m 'init project'
[master (root-commit) 679e31d] init project
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
В коде выше две новых команды. Первая git add подготавливает изменённый или добавленный файл к коммиту. Без её выполнения сделать коммит не получится. Подробнее на ней мы остановимся позже. А вот команда git commit непосредственно фиксирует изменения в репозитории. Ключ -m позволяет добавить короткое описание коммита. Если выполнить коммит без этого ключа, то откроется редактор с информацией о коммите. Git ожидает, что вы оставите описание коммита и выйдете из редактора. Дальше Git самостоятельно завершит свою работу.

Коммит в Git невозможно выполнить, не добавив к нему описание. Благодаря описанию мы можем просматривать историю коммитов и анализировать её без необходимости изучать изменения произведённые коммитом. Поэтому хорошее описание коммита очень важно. На просторах сети можно найти множество статей, посвящённых тому, как их именовать.

Рабочий процесс
Дальнейший рабочий процесс выглядит так:

Добавляем или изменяем файлы и директории.
Подготавливаем новое содержимое к коммиту командой git add. Эту команду нужно применять даже в том случае, если файл был просто изменён.
Выполняем коммит.
example$ echo 'my first change' >> README.md # Добавляем новую строку в файл
example$ git add README.md # Подготовка к коммиту
example$ git commit -m 'update readme'
[master 3a64fcc] update readme
 1 file changed, 1 insertion(+)

example$ cat README.md
# Hi
my first change
История: git log
Теперь можно посмотреть историю коммитов:

example$ git log

commit 3a64fccf14725593b7486ff09d6a6c325a5f8fcc
Author: Kirill Mokevnin <mokevnin@gmail.com>
Date:   Mon Jun 26 15:01:22 2017 +0300

    update readme

commit 679e31d62ac734e3074f092e417ba741be767a0d
Author: Kirill Mokevnin <mokevnin@gmail.com>
Date:   Mon Jun 26 14:35:47 2017 +0300

    init project
В выводе лога каждый коммит описывается таким набором данных:

Идентификатор коммита, например, 679e31d62ac734e3074f092e417ba741be767a0d.
Информация об авторе. Имя и адрес электронной почты, которые вводились во время конфигурации Git.
Дата коммита.
Описание коммита. Сообщение, которое вводилось при выполнении коммита.
Идентификатор коммита играет очень важную роль в жизненном цикле репозитория, и мы не раз к нему ещё вернёмся. Главное, что сейчас можно отметить: идентификатор представляет из себя хеш, а не последовательный номер (как в некоторых других системах).

Команда git log – очень мощный инструмент, у неё огромное количество опций, которые способны извлекать из истории все, что угодно в совершенно разных представлениях. Как правило, для нормальной повседневной работы, достаточно буквально нескольких разновидностей запросов к истории. Остальное легко ищется в интернете по мере надобности. Очень полезен такой вариант использования:

example$ git log -p

commit 3a64fccf14725593b7486ff09d6a6c325a5f8fcc
Author: Kirill Mokevnin <mokevnin@gmail.com>
Date:   Mon Jun 26 15:01:22 2017 +0300

    update readme

diff --git a/README.md b/README.md
index 76f177f..13f5a93 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,2 @@
 # Hi
+my first change

commit 679e31d62ac734e3074f092e417ba741be767a0d
Author: Kirill Mokevnin <mokevnin@gmail.com>
Date:   Mon Jun 26 14:35:47 2017 +0300

    init project

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..76f177f
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# Hi
Он выводит непрерывную разницу (diff) всех изменений по коммитам. Строчки, в которых слева находится знак +, добавлены в этом коммите, а строчки, в которых есть - — удалены. Нажимая f и b в этом выводе, можно перемещаться по истории изменений если она не помещается на экран.

Просмотр изменений
Зная идентификатор коммита можно посмотреть изменения в коде.

$ git show 3a64fccf14725593b7486ff09d6a6c325a5f8fcc

diff --git a/README.md b/README.md
index 76f177f..13f5a93 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,2 @@
 # Hi
+my first change
Вывод выше можно было бы получить и так:

$ git show 3a64fcc
То есть достаточно указать только первые 7 символов идентификатора коммита. Это сделано исключительно для удобства, так как вероятность коллизий (пересечений) крайне низка.

С другой стороны, команда git diff, запущенная без аргументов, показывает различия между репозиторием и вашей рабочей копией. Её полезно запускать тогда, когда вы хотите посмотреть изменения сделанные в рабочей копии, но не добавленные для коммита командой git add.

Сам вывод с непривычки кажется странным и единственный способ разобраться с ним – практика и только практика.
Состояния файлов в Git
Перед этим и последующими уроками обязательно нужно потренироваться с базовыми командами.

Если посмотреть на вывод команды git status репозитория, в котором были сделаны все возможные изменения, такие как добавление нового файла, изменение и удаление, то он будет выглядеть примерно так:

lasso$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed: # Изменения, попадающие в следующий коммит

    new file:   .editorconfig
    modified:   Dockerfile

Changes not staged for commit: # Изменения, которые не попадут в коммит

    modified:   docker-compose.yml
    deleted:    rebar.lock

Untracked files: # Неотслеживаемые файлы

    Procfile

Не вдаваясь в детали можно сказать, что у любых файлов, с которыми мы работаем, внутри рабочей копии есть разные состояния. И именно им посвящён данный урок.

Неотслеживаемые файлы
В первую очередь все файлы делятся на отслеживаемые (tracked) и неотслеживаемые (untracked). Untracked – это новый файл, который не был добавлен для отслеживания командой git add. Все остальные файлы являются tracked.

lasso$ touch .editorconfig
lasso$ git status

On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files: # Тут не отслеживается

    .editorconfig

lasso$ git add .editorconfig
lasso$ git status

On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed: # Тут отслеживается

    new file:   .editorconfig
С непривычки такое поведение может показаться странным. Почему бы сразу не давать возможность коммитить, без необходимости добавлять файл в отслеживаемые?

На самом деле такое поведение очень важно. Как вы убедитесь в своей практике, множество инструментов генерирует свои файлы (например, редакторы, операционная система, пакетные менеджеры), а запуск программ порождает файлы с логами и другие артефакты. И если бы git commit автоматически включал все новые файлы, в репозиторий после коммитов постоянно попадали бы ненужные данные.

Если вы заметили такие файлы, то их нужно добавить в специальный файл .gitignore, который поможет Git определить то, что точно не придётся коммитить. Больше вы эти файлы и директории не увидите даже после команды git status. Всё, что перечислено в этом файле, закоммитить не удастся. Правда, если вы хотите добавить в .gitignore то, что уже было закоммичено, предварительно придётся удалить соответствующие данные из репозитория с помощью команды git rm.

Формат файла простой, его можно подсмотреть в одном из наших репозиториев.

Отслеживаемые файлы
С отслеживаемыми файлами всё сложнее. Начнём с того, что они тоже могут находиться в 3-х разных состояниях:

неизменённое (unmodified)
изменённое (modified)
подготовлено к коммиту (staged)
С неизменённым состоянием всё просто. Если файл в рабочей копии точно такой же как и в репозитории, то считается что его не модифицировали. Любой файл после коммита переходит в состояние unmodified. Соответственно, команда git status никак не отражает это состояние.

Изменённое состояние тоже интуитивно понятно. Как только мы изменили любой файл в состоянии unmodified (но не untracked!), он автоматически становится modified. И вот тут нас поджидает сюрприз: если попробовать вызвать git commit, то файлы в состоянии modified в него не попадут. Предварительно их нужно перевести в состояние staged сделав git add. В этом и заключается смысл команды git add, она переводит файлы с любым состоянием, кроме unmodified, в состояние staged. Это касается и файлов в состоянии untracked. И только после этого они попадут в коммит.

Я понимаю, что абзац выше может снести крышу, это нормально. Понимание состояний Git – это не то, что можно понять и простить исключительно по чтению учебных руководств. Единственное, что поможет – постоянная практика. Если сейчас вы поняли, что стало очень сложно – не отчаивайтесь, дочитайте до конца (как мы рекомендуем) и поэкспериментируйте.

Git Files Lifecycle

По большому счёту наличие состояния staged не является критически необходимым, другими словами, можно было реализовать git и без этого промежуточного звена. Но сделан он не просто так, и его польза станет понятна только со временем. Главная идея в том, что во время работы над репозиторием, как правило, делаются несвязанные изменения в разных местах, например, вы делали какую-то фичу, а попутно отрефакторили код, который вам не понравился. Если этот код не имеет отношения к задаче, то, исходя из понятия "хороший коммит", он должен быть закоммичен отдельно. Так вот, такое можно сделать именно благодаря наличию состояния staged. Делается это посредством интерактивного добавления git add -i, во время которого Git показывает фрагменты изменённого кода и спрашивает, нужно ли добавить это изменение в staged (или, как говорят, "в индекс").

Сброс изменений файла
Мы научились добавлять файлы в индекс, но что делать если мы наоборот хотим их удалить из него? Для этого нам помогут две команды: reset и checkout.

git reset path/to/file переводит файл из состояния staged в modified
git checkout -- path/to/file переводит файл из состояния modified в unmodified, то есть по сути эта команда сбрасывает изменения.

Думай как Git
В основе Git лежит несколько базовых идей, понимание которых крайне важно для эффективной работы. Разберём их.

Снимки вместо различий
Snapshot Stream

Git работает со снимками, а не с дельтой изменений. Каждый раз, когда делается коммит, создаётся слепок всего репозитория (внутри, конечно, всё оптимизировано, но детали реализации нас не интересуют). Когда мы используем git diff, Git динамически высчитывает разницу и показывает нам.

В этом легко убедиться, если выполнить git checkout идентификатор. После этой команды, в рабочей копии окажется то состояние репозитория, которое было на момент коммита идентификатор.

Почти каждая операция локальная
Изменение файлов
Коммиты
Работа с историей
Об этом уже говорилось, но не лишним повторить ещё раз. Git – децентрализованная система, каждый репозиторий полностью (почти) автономен.

Git — целостный
Невозможно изменить содержимое репозитория таким образом, чтобы гит об этом не узнал

Git — это про добавление данных
Удаление не удаляет
Изменение не изменяет
Даже если вы удаляете данные, это приводит всего лишь к тому, что они пропадают в рабочей копии, но папка .git помнит всё. Неизменяемые данные – ключевая стратегия, приводящая к таким возможностям как возврат в истории, откаты изменений и многое другое.

Кстати, по этой причине желательно не хранить в Git большие бинарные файлы (например архивы), так как это приводит к сильному распуханию папки .git.

Три состояния Git
Areas

Файлы в состоянии staged, в отличие от modified и untracked, находятся в специальной области, называемой областью подготовленных файлов (staging area) внутри директории .git. Её ценность станет понятнее, когда вы познакомитесь с ветвлением.

Ветки в Git
Запуск git status в чистой рабочей копии выводит следующую информацию:

git_course$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
Вывод говорит о том, что мы находимся в ветке master. Дополнительно в этом можно убедиться с помощью специализированной команды git branch.

racket$ git branch
* master
Для понимания значения слова «ветка» давайте посмотрим, что из себя представляет история коммитов:

Git Master

Слева первый коммит, затем второй, который ссылается на первый, а в конце третий. Каждый новый коммит содержит ссылку на предыдущий. Это позволяет прослеживать связь между коммитами, а способ организации коммитов называется линейный список.

Представьте ситуацию, в которой появилось два коммита, родителем которых является один и тот же коммит:

Git Branches

Из картинки видно, что наш список превратился в дерево, в котором две ветки. Каждая ветка – это своё собственное развитие исходного кода. Как нетрудно догадаться, таких веток может быть сколько угодно, и порождаться они могут из любого коммита любой ветки (дерево же).

Только что инициализированный репозиторий содержит только одну ветку — master. Она используется в качестве основной и выбрана сразу. Как только вы начинаете работать с новыми репозиторием, вы работаете в ветке master, её не нужно специально выбирать. Всё остальное опционально. Вот основные причины использовать ветвление:

Одновременная поддержка нескольких версий. Такое всегда есть у коробочного софта. Например, версии браузеров или операционных систем.
Работа над задачами в ветках не блокирует возможность правок в основной ветке. Например, во время реализации сложной функциональности может потребоваться срочно внести изменение в работающий проект.
Ниже пример того, как в git работать с ветками:

racket$ git branch new-feature # создание новой ветки
racket$ git branch
* master
  new-feature

racket$ git checkout new-feature # переключение на новую ветку
Switched to branch 'new-feature'

racket$ git branch
  master
* new-feature

racket$ git log --oneline --decorate --graph
* c082d77 (HEAD -> new-feature, master) fix stripping
* 442c2fd Correct typo
* b2b53d6 fix test that uses IPv6
Некоторые выводы из приведённого листинга:

Каждая ветка имеет уникальное имя, которое задаётся при создании ветки.
Команда git branch показывает не только все доступные ветки, но также и отмечает текущую символом *.
У внимательного читателя возможно возник вопрос: как Git определяет, где мы сейчас находимся? Ответ на этот вопрос можно увидеть в этой строчке:

* c082d77 (HEAD -> new-feature, master) fix stripping
Любой односвязный список содержит голову (HEAD). Это последний добавленный в него элемент (в списках добавление всегда идёт в начало, то есть новая голова "нанизывается" на предыдущую голову). Git работает точно так же: когда мы делаем любой коммит, он становится HEAD. Другими словами, понятие HEAD это, по сути, ссылка на некоторый коммит. А отсюда следует интересная вещь. Помните, что мы можем переключиться на любой коммит (абсолютно любой) и загрузить его снимок в рабочую копию командой git checkout идентификатор? Так вот, после того, как мы это проделаем, HEAD начинает указывать именно на загруженный коммит. Внутри происходит изменение указателя HEAD и загрузка в рабочую копию соответствующего снимка.

racket$ git checkout ed8145e
racket$ git status
HEAD detached at ed8145e

racket$ git checkout master
Previous HEAD position was ed8145e... fix doc typo
Switched to branch 'master'
Каждая ветка – это всего лишь точно такой же указатель на определённый коммит, а сами ветки определяются исключительно связями между коммитами. В этом легко убедиться, если изучить папку refs внутри .git:

racket$ ls .git/refs/heads/
master      new-feature

racket$ cat .git/refs/heads/new-feature
c082d77c971f7a042cf69de9df150c80e9384b71

racket$ cat .git/HEAD
ref: refs/heads/new-feature
Видно, что ветка – это файл с именем ветки и записанным в него идентификатором коммита, а HEAD – это файл, внутри которого стоит ссылка, в данном случае на new-feature. То есть это состояние ситуации, при которой мы только что переключились на ветку new-feature, и HEAD совпадёт с последним коммитом в new-feature.

Из всего сказанного следует, что коммиты не принадлежат веткам. Структура коммитов существует сама по себе безотносительно них. Ветки накладываются поверх коммитов как указатели. Это, например, означает, что изменение коммита общего для нескольких веток (а такое можно делать используя rebase) отражается на всех ветках, в которые попал этот коммит.

Слияние
Предположим, что вы реализовали фичу и теперь хотите, чтобы этот код оказался в ветке master. Делается это командой git merge, которая сливает ветки между собой. Результатом слияния становится особенный merge commit. Его отличие от остальных коммитов в том, что этот коммит не содержит изменений, но он ссылается сразу на двух родителей, которыми выступают последние коммиты в какой-либо ветке и ветке master в момент слияния. Именно благодаря тому, что он ссылается на последний (на момент слияния) коммит из ветки, Git узнает о том, какие были выполнены изменения и как нужно изменить код мастера.

Git Merge

racket$ git checkout master
racket$ git merge new-feature
Updating c082d77..d7b64b2
Fast-forward
 INSTALL.txt | 1 +
 1 file changed, 1 insertion(+)
Команда git merge выполняется из той ветки, в которую мы сливаем изменения, а аргументом передаётся имя той ветки, которую мы сливаем.

Перемещение
Команда git rebase относится к продвинутым техникам Git, но именно она делает вас настоящим властелином репозиториев. Как только основы будут освоены, окунитесь в её изучение.

Дополнительно
https://learngitbranching.js.org/

<span class="translation_missing" title="translation missing: ru.web.courses.lessons.mentors.mentor_avatars">Mentor Avatars</span>
Остались вопросы? Задайте их в разделе «Обсуждение»
Вам ответят менторы из команды Хекслета или другие студенты.

Распределенный Git
На протяжении курса я постоянно подчёркиваю две вещи:

Отсутствует сервер
Локальный репозиторий самодостаточен
Но тогда возникает вопрос: а каким образом, используя Git, можно вести совместную разработку? И в этом нам поможет ещё одна особенность Git — умение взаимодействовать с удалёнными репозиториями.

Рабочий процесс, в котором задействованы несколько разработчиков (или один, но работающий из разных мест), должен выглядеть хотя бы так:

Centralized Workflow

Это не единственный способ работы, но самый простой. Он требует наличия центрального репозитория, через который идёт обмен кодом. С точки зрения Git, этот репозиторий немного особенный и создаётся он специальным образом (у него нет рабочей копии).

$ mkdir example_bare
$ cd example_bare
example_bare$ git init --bare
Если в обычной ситуации инициализация репозитория приводит к созданию вложенной директории .git, то в случае чистого (bare) репозитория, содержимое директории выглядит так:

example_bare$ ls
HEAD    config    description    hooks    info    objects    refs
Это ровно те же директории, которые мы наблюдали внутри .git при обычной инициализации. Для чистого репозитория эти директории создаются на верхнем уровне, без вкладывания в .git.

Теперь можно перейти в другую директорию и попробовать клонировать только что созданный репозиторий. Для простоты используем директорию /tmp.

$ cd /tmp
# Переименуем папку клонированного репозитория для того чтобы не путаться
tmp$ git clone ~/example_bare clone_of_example
Cloning into 'clone_of_example'...
done.

tmp$ cd clone_of_example
Подчеркну, что по сути у нас получилось два разных репозитория, каждый живёт своей жизнью, даже несмотря на то, что после клонирования есть связь, и мы можем отправлять изменения в основной репозиторий.

А вот как на самом деле связан наш клон с основным репозиторием:

clone_of_example$ git remote -v
# В вашем случае путь будет отличаться,
# он зависит от операционной системы и того где вы инициализировали репозиторий
origin  /home/user/example_bare (fetch)
origin  /home/user/example_bare (push)

# То же самое через чтение конфига
clone_of_example$ cat .git/config
[remote "origin"]
    url = /home/user/example_bare
    fetch = +refs/heads/*:refs/remotes/origin/*
Как видите, нет никакой магии: вся связь – это несколько записей в файле .git/config, в котором origin – это произвольное имя (можно поменять) удалённого репозитория, с которым связан текущий. Кстати, таких удалённых репозиториев может быть сколько угодно. На практике такое поведение действительно бывает нужно, когда изменения отправляются сразу в несколько мест.

Давайте теперь посмотрим на главное — как отправлять изменения:

Отправка изменений
clone_of_example$ echo '# Hello' > README.md
clone_of_example$ git add README.md
clone_of_example$ git commit -m 'add readme'
[master 144d274] add readme
 1 file changed, 1 insertion(+), 0 deletions(-)

# Отправка
clone_of_example$ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 253 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /home/user/example_bare
   3a64fcc..144d274  master -> master
Итак, у нас добавилась новая команда — git push. Эта команда выполняет отправку новых коммитов из текущего репозитория в удалённый. Здесь origin — имя удалённого репозитория, master — конкретная ветка, в которую отправляются (разг. пушатся) изменения. Каждый раз набирать эту команду полностью довольно утомительно. Поэтому Git позволяет не указывать удалённую ветку, если сделать её «отслеживаемой веткой» (upstream branch).

Отслеживаемая ветка напрямую связана с веткой на удалённом репозитории. Это позволяет сократить отправку изменений до команды git push без указания параметров. Крайне важно понимать, что одинаковые названия веток в разных репозиториях для Git ничего не значат. Каждой ветке нужно установить соответствие (когда вы делаете git push, Git сам предложит команду, выполнив которую установится трекинг). Понятно, что на практике названия веток почти всегда совпадают.

Отслеживаемая ветка устанавливается командой git push --set-upstream origin master. Эта команда выполняет два действия: устанавливает отслеживание и отправляет изменения. Она выполняется ровно один раз, далее можно отправлять изменения набирая просто git push. Информация об отслеживаемой ветке описывается в файле .git/config в виде секций [branch "имя ветки"]:

clone_of_example$ cat .git/config
[branch "master"]
    remote = origin
    merge = refs/heads/master
Получение изменений
А теперь представьте себе ситуацию: вы делаете git push, а в это время, кто-то другой уже отправил свои изменения. В такой ситуации Git скажет, что он уже не может отправить ваши изменения. Теперь вам нужно получить изменения, сделанные в удалённом репозитории, а затем слить их со своими. Делается это командой git pull:

tmp$ git clone ~/example_bare clone_of_example2
$ cd clone_of_example2
clone_of_example2$ git pull
Updating 3a64fcc..144d274
Fast-forward
 README.md | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)
Команда git pull отработает предсказуемым образом в том случае, если в нашей локальной ветке не было изменений и произойдёт так называемое слияние в режиме fast forward. То есть просто добавятся новые коммиты так, как будто мы их локально прямо сейчас и сделали. А что будет в ситуации, когда мы делаем git pull, а в локальной ветке есть зафиксированные изменения?

А произойдёт самый настоящий git merge. Под капотом git pull делаются две операции — одна git fetch, которая просто получает изменения и складывает их к себе во внутренности директории .git, а вторая — git merge.

Хорошая практика с Git подразумевает отсутствие коммитов слияния (разг. мержкоммиты) при скачивании изменений в локальный репозиторий, поэтому использовать git pull не рекомендуется. Чтобы история была «прямой», нужно использовать rebase, например, так git pull --rebase. Если в процессе возникнут конфликты, то вас попросят их решить. Подробнее про rebase в этой статье.

Ветвление
Если вы хотите посмотреть на то, как выглядит история коммитов с учётом ветвления, вам поможет команда, показанная ниже.

racket$ git log --oneline --decorate --graph
* d7b64b2 (HEAD -> master, new-feature) implement new feature
* c082d77 (origin/master, origin/HEAD) fix stripping
* 442c2fd Correct typo
* b2b53d6 fix test that uses IPv6
<span class="translation_missing" title="translation missing: ru.web.courses.lessons.mentors.mentor_avatars">Mentor Avatars</span>
Остались вопросы? Задайте их в разделе «Обсуждение»
Вам ответят менторы из команды Хекслета или другие студенты.

Github
Centralized Workflow

Использование схемы работы с центральным репозиторием требует наличия отдельного места в сети. Задача настолько распространённая, что появилось множество сервисов, ориентированных на хостинг git-репозиториев. Одним из первых был GitHub.

GitHub (разг. гитхаб) — это, во-первых, сайт, а во-вторых, центральная площадка в интернете, на которой размещают свои git-репозитории практически все существующие опенсорс-проекты, а также многие закрытые. Грубо говоря, GitHub предоставляет визуальный интерфейс для управления git-репозиториями.

GitHub

И если изначально GitHub делался для кода, то сейчас его используют для всего, что может быть представлено текстом. Например, пишут или переводят книги.

Test Assignments

У GitHub прекрасная документация, которая описывает то, как с ним можно работать:

Github Guides

Чтобы начать работу с GitHub вам необходимо выполнить следующие действия:

Зарегистрироваться на сайте
Создать репозиторий по инструкции. После создания появится страница, на которой подробно описано, как действовать дальше.
Клонировать репозиторий по инструкции. Не забудьте перейти в директорию с репозиторием.
Выполните изменения в склонированном на ваш компьютер репозитории, а затем отправьте (git push) их обратно на GitHub.
Github

Ниже приведён пример работы с репозиторием на GitHub.

# Пример клонирования репозитория https://github.com/Hexlet/ru-test-assignments в директорию /tmp

# Клонирование
tmp$ git clone https://github.com/Hexlet/ru-test-assignments.git
Cloning into 'ru-test-assignments'...
remote: Counting objects: 127, done.
remote: Compressing objects: 100% (9/9), done.
remote: Total 127 (delta 4), reused 4 (delta 1), pack-reused 112
Receiving objects: 100% (127/127), 22.84 KiB | 135.00 KiB/s, done.
Resolving deltas: 100% (34/34), done.

# Переход в папку с проектом
tmp$ cd ru-test-assignments
ru-test-assignments$ ls
README.md

# Здесь какие-то изменения README.md

# Проверка состояния
ru-test-assignments$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")

# Добавление изменения в индекс
ru-test-assignments$ git add README.md

# Коммит
ru-test-assignments$ git commit -m 'update readme'
[master dbd23b9] update readme
 1 file changed, 16 insertions(+), 16 deletions(-)

# Отправка изменений на GitHub
ru-test-assignments$ git push
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 346 bytes | 346.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:Hexlet/ru-test-assignments.git
   80d23b1..dbd23b9  master -> master
Тестовые задания
В одном из публичных репозиториев Хекслета мы собираем тестовые задания разных компаний. Выполнение этих заданий – прекрасная возможность потренировать работу с Git.

Самостоятельная работа
Создайте аккаунт на GitHub
Создайте репозиторий hexlet-basics
Склонируйте этот репозиторий локально, добавьте в него README.md и отправьте код на Github. Убедитесь, что на сайте отобразились изменения.

Fork и Pull Requests
Open Source Software (OSS; разг. опенсорс) — это ПО, чей код открыт (его можно посмотреть) и на чей код почти всегда можно влиять.

Мы, как программисты, каждый день пользуемся программным обеспечением с открытым исходным кодом. К такому ПО относится как прикладное, например, Linux или Git, так и огромное число библиотек в нашем коде, а также практически все современные языки программирования. Та скорость, с которой возможна разработка современных проектов, во многом обязана как раз тем самым программам (и библиотекам) с открытым исходным кодом.

Linux (> 12 миллионов строк кода)
Chromium (> 16 000 000)
Git
jQuery
Откуда они вообще берутся и почему так популярны? Почти всегда такой код появляется как побочный продукт разработки проектов. Например, в процессе разработки Linux, появилась необходимость в удобной программе для управления версиями. Так появился Git. Но почему его код был открыт? Ответ достаточно простой. Удачные проекты привлекают множество разработчиков, которые помогают развиваться. Пишут отчёты об ошибках, присылают исправления и даже становятся полноправными разработчиками. И всё это бесплатно. Разработчики удовлетворяют своё эго, радуются тому, что создают нечто новое и вообще помогают этой вселенной.

Если вернуться в прошлое и посмотреть, сколько опенсорс-проектов создавалось тогда и сколько там было задействовано людей, то вы бы увидели огромный разрыв с современным положением дел. Сложный процесс включения в разработку, сложный процесс принятия изменений — вот неполный перечень проблем, ожидавших тех, кто желал стать участником этого движения. Люди выступали с докладами на конференциях, где час (Карл!!!) описывали правила принятия людей и кода от них в проект.

Сейчас начать делать опенсорс стало делом пары минут, а чтобы начать где-то участвовать не нужно прилагать практически никаких усилий. А случилось это благодаря двум составляющим: Git и GitHub.

Один из важнейших механизмов GitHub — запрос на включение изменений (pull request; разг. пулреквест). Именно он позволяет легко и непринуждённо вливаться в разработку любых проектов. Допустим, работая с определённой библиотекой мы заметили ошибку в коде или документации.

Пройдёмся по шагам, которые необходимо выполнить для исправления этой ошибки. Наша конечная цель в том, чтобы разработчики библиотеки приняли наш код.

Клонирование
Первым шагом необходимо создать копию (клон) репозитория в своём аккаунте. Делается это буквально одной кнопкой «Fork» на странице репозитория.

После этого действия в вашем аккаунте окажется репозиторий с таким же именем. GitHub знает, что это копия оригинального репозитория и помечает его особым образом. Дальше всё как обычно. Мы клонируем репозиторий на компьютере и производим необходимые изменения. Хорошей практикой считается делать изменения в отдельной ветке (обычно созданной от master).

Запрос на включение изменений кода
После того, как изменения залиты на GitHub, в его интерфейсе произойдут изменения. На странице склонированного репозитория появится кнопка «pull request». Если её нажать, то откроется страница, на которой можно указать название пулреквеста и его описание. После отправки пулреквеста в исходном (оригинальном) репозитории на странице «Pull requests» отобразится ваш запрос. Теперь остаётся ждать, когда разработчики библиотеки либо его примут, либо отклонят, либо зададут уточняющие вопросы (и с ним, возможно, потребуется ещё поработать).

2. Основные принципы работы


Как я уже говорил, работать с VIM можно, только понимая его идеологию. Чем же он отличается от "обычных" редакторов?

Далее постараюсь быть лаконичным и исключить лирику для лучшего восприятия материала – уж очень это серьезное дело. Текстовый редактор VIM может находиться в одном из трех состояний (В скобках указаны оригинальные английские названия):

Режим ввода команд (NORMAL).

Режим редактирования (INSERT).

Режим выделения текста (VISUAL).



Существуют еще режим совместимый с VI - он нас не интересует, и режим выделения текста эмулирующий поведение обычных редакторов под Windows - Select, но при этом мы теряем больше, чем находим, и я его рассматривать не буду.

Рассмотрим подробнее каждое состояние редактора. Каждое состояние соответствует определенному режиму работы, предназначенному для выполнения определенных операций.

- NORMAL: // В этом режиме выполняются различные команды, такие как чтение-запись файлов, изменение параметров редактора и др.

- INSERT: // В этом режиме осуществляется вставка текста и непосредственное редактирование.

- VISUAL: // В этом режиме можно выделять текст для последующих манипуляций, таких как удаление, перемещение по листу, копирование в один из регистров изменение форматирования и др.

Имея три основных режима работы, мы должны оперативно между ними переключаться. Основным режимом принято считать режим NORMAL. Поэтому все переходы осуществляются через него.


Переход

Команда

Комментарий

Из режима

В режим

NORMAL

INSERT

i или "Insert" //Кнопка клавиатуры "Insert" кроме того переключает режимы вставки – замены.

INSERT

a //Вставка текста после символа, подсвеченного курсором

INSERT

o //Вставка новой строки после курсора с переходом в режим INSERT

INSERT

O //Вставка новой строки перед курсора с переходом в режим INSERT

INSERT

cc, S //Очистка строки и переход в режим INSERT

INSERT

C //Удалить правую часть строки и переход в режим INSERT

INSERT

s //Удалить подсвеченный символ и переход в режим INSERT

VISUAL

v //Режим выделения текста (с точностью до знака)

VISUAL

V //Режим выделения текста (с точностью до строки)

VISUAL

Ctrl+V (Ctrl+Q) //Режим выделения прямоугольной области текста, следует отметить, сто комбинация клавиш Ctrl+V в Windows используется для вставки текста из буфера, поэтому вместо нее следует использовать альтернативный вариант Ctrl+Q.

VISUAL

gv //Возврат к области, выделенной в прошлый раз.

NORMAL или INSERT

VISUAL

<LeftMouse>

Прекращает выделение или начинает новое

VISUAL

<RightMouse>

Продолжает выделять область

INSERT

NORMAL

ESC //Выход в режим NORMAL


NORMAL

Ctrl+O //Кратковременный выход в режим NORMAL для выполнения одной команды, после чего осуществляется автоматический возврат в режим INSERT

VISUAL

NORMAL

Ctrl+c, v, V,.. //Вернуться в NORMAL можно повторив ту комбинацию, с помощью которой вы вошли в VISUAL. При этом не будет выполнено никаких действий над выделенной областью. Любая команда которая совершается над выделенной областью также переводит редактор в режим NORMAL, но подробно эти операции будут рассмотрены позже.


Далее я буду рассматривать как выполняются те операции, к которым мы привыкли, используя "традиционный" ТР с графическим интерфейсом (если кто помнит, то были строчные и экранные редакторы, так вот VIM, на мой взгляд, ближе к строчным). VIM имеет множество команд типа "удалить 10 слов от текущего положения курсора" или "перейти на 4 слова влево". Глупо говорить, что такие команды не нужны, просто современный рядовой пользователь не привык к таким командам – его орудие мышка. И вот как раз такому человеку будет интересно (надеюсь) прочитать далее, как можно выполнять привычные для него действия в таком своеобразном редакторе.



3. Чтение файла, сохранение, выход из программы

Итак, самые главные операции, которые необходимы любому ТР. Общая идея заключается в том, что VIM имеет некий набор буферов и экранов. Буфер – это собственно файл (не совсем корректно, но в первом приближении сойдет), а экран это то окно, в котором отображается буфер.

Все операции по работе с файлами, буферами и экранами осуществляются из режима NORMAL .

:edit // чтение файла и большинство вариаций на эту тему осуществляется с помощью этой команды. Общий формат команды имеет вид (здесь и далее в квадратные скобки заключаются необязательные элементы):

:e[dit][!] [++opt] [+cmd] [Имя файла]

где

++opt – это параметр позволяющий изменить значения fileformat и fileencoding, персонально для открываемого файла. Могут быть полезны следующие варианты:

++enc=koi8-r // устанавливает кодировку открываемого файла

++enc=koi8-u


++enc=cp1251


++enc=latin1


++ff=unix

строки заканчиваются символом <NL>

++ff=dos

строки заканчиваются символом <CR><NL>

++ff=mac

строки заканчиваются символом <CR>

+cmd – параметр позволяющий указать положение курсора для открываемого файла или выполнить другую команду.



Вопрос работы с различными русскими кодировками рассмотрен подробнее в соответствующем разделе.


Возможные варианты сохранения файла показаны в таблице:

Команда

Описание

NORMAL

:w[rite] // Сохранить текущий буфер

:w! // Сохранить текущий буфер не взирая на атрибут “только для чтения”

:sav[eas][!] {file} // Сохранить буфер под новым именем, имя текущего буфера тоже меняется. Предыдущее имя используется как альтернативное. Флаг “!” необходим для записи поверх существующего файла.

:wa[ll] // Сохранить все содержимое всех буферов, котрые были изменены

:wq[!] // Сохранение файла и выход из программы


Вопрос работы с различными русскими кодировками рассмотрен подробнее в соответствующем разделе.

:q[uit] // обеспечивает выход из программы. Если один из открытых файлов был изменен и не сохранен, то для выхода из программы необходимо использовать :q! или предварительно сохранить все файлы.

4. Навигация по тексту

Для эффективного редактирования текста мы должны иметь возможность перемещаться по нему в любом направлении и к любому его фрагменту. VIM имеет для этого потрясающие и очень разноплановые возможности. Начнем с простого. для перемещения курсора традиционно используются следующие клавиши (только режим NORMAL ): 'h' – влево, 'j' – вниз, 'k' – вверх, 'l' – вправо.

Такой подход обеспечивает максимальную скорость, для людей владеющих "слепой печатью", так как избавляет их от необходимости убирать руки от основной клавиатуры. Для людей владеющих "однопальцевой печатью" в последних версиях VIM добавлена возможность перемещения по файлу с помощью традиционных клавиш как в режиме NORMAL , так и в режиме INSERT . Но такие манипуляции далеко не предел возможностей VIM. Далее привожу сводную таблицу соответствующих команд. Надо заметить, что VIM поддерживает технологию подобную гиперссылкам.


Команда

Описание

Общие

<HOME> // Переход в начало строки

<END> // Переход в конец строки



NORMAL

f{символ} // Поиск указанного символа в текущей строке вправо

F{символ} // Поиск указанного символа в текущей строке влево

% // Переход к парной скобке – очень удобно при написании программ на С/С++, Lisp

{nn}G или {nn}gg // Переход к строке nn, если номер строки не указан, то G – переход в конец, а gg – в начало документа. Эта функция очень помогает при отладке программ, однако VIM имеет специальный инструментарий для создания удобной среды разработки. Этот вопрос рассмотрен далее

CTRL+O // Возврат на предыдущую позицию (при переходах по документам с помощью меток, именованных меток, ссылок или с помощью команд gg и G)

CTRL+I // Команда обратная по действию CTRL+O. Подробнее смотрите описание использования меток.

* // Переход на следующее слово, аналогичное подсвеченному курсором. (Поиск слова, на котором в данный момент стоит курсор, далее по тексту)

# // Переход на следующее слово, аналогичное подсвеченному курсором  в обратном направлении

) // Переход на начало следующего предложения

( // Переход на начало предыдущего предложения

} // Переход на начало следующего параграфа

{ // Переход на начало предыдущего параграфа

[m  // Переход назад к началу описания метода (Java)

[M  // Переход назад к концу описания метода (Java)

]m  // Переход вперед к началу описания метода (Java)

]M  // Переход вперед к концу описания метода (Java)

[* // Переход назад к началу блока коментария (/*)

]* // Переход вперед к концу блока коментария (*/)

CTRL+] // Переход по ссылке

INSERT




Очень полезными могут оказаться именованные метки, особенно, когда приходится вносить изменения в нескольких частях одного документа. Для работы с именованными метками используются следующие команды:


Команда

Описание

NORMAL

m{имя} // Установить метку с именем {имя}. Именем метки может быть любая (одна) буква

'{имя} // Переход к строке с указанной меткой

`{имя} // Переход в конкретное место (строка и столбец) помеченное меткой

:marks // Показать все определенные метки




Кроме определяемых пользователем, имеются также предопределенные метки:

Метка

Описание

' // Позиция курсора до перемещения (метка, ссылка, поиск ...)

" // Позиция курсора во время последнего редактирования

[  // Начало последнего изменения

] // Конец последнего изменения

5. Редактирование
Под редактированием я понимаю различные манипуляции над текстом и его форматированием. Соответственно для каждого из режима доступны различные команды. В режиме VISUAL осуществляются изменения выделенного участка текста. В режиме NORMAL в качестве обьекта редактирования выступает текущая строка, слово или символ. Корректура собственно текста осуществляется непосредственно в режиме INSERT, в котором вы можите добавлять новые символы, удалять или заменять старые. Естественно и ввод текста осуществляется в этом режиме.



Команда

Описание

VISUAL

~ // Изменить регистр выделенного фрагмента текста

c [x] // Удалить выделенный участок в регистр “x” и перейти в режим вставки

> // Сдвинуть выделенный фрагмент вправо

< // Сдвинуть выделенный фрагмент влево

! // Отфильтровать выделенные строки с помощью внешней программы

NORMAL

<DEL>, x // Удалить символ правее курсора

X  // Удалить символ левее курсора

dd // Удалить текущую строку

u // Отмена последнего действия

CTRL-R // Вернуть исправления

D // Удалить до конца строки

.  // Повторить последнее действие

r // Заменить символ подсвеченный курсором

~ // Поменять регистр символа под курсором



INSERT

<CTRL> + A // Вставляет тект, который был введен в прошлый insert-сеанс

<CTRL> + W // Удаляет предыдущее слово

<DEL> // Удаляет следующий символ

<CTRL> + N // Автоматическое завершение слова с поиском вперед по тексту

<CTRL> + P // Автоматическое завершение слова с поиском назад по тексту

<CTRL> + T // Вставить табуляцию в начало текущей строки

<CTRL> + D // Удалить табуляцию из начала текущей строки

<CTRL> + Q // Вставляет символ, код которого следует за нажатием комбинации.

<CTRL> + X // Переходит в дополнительный режим, в котором вы можите выполнять автозавершение или другие полезные действия. Подробнее этот режим рассмотрен далее.

<CTRL> + E // Вставляет символ, который находится в той же позиции, что и курсор, но ниже.

<CTRL> + Y // Вставляет символ, который находится в той же позиции, что и курсор, но выше.


Особый интерес представляет дополнительный режим, в который можно перейти из режима INSERT, нажав комбинацию клавиш <CTRL> + X. Чтобы выполнить требуемое действие вам необходимо выбрать одну из следующих комбинаций:



Комбинация

Описание

<CTRL> + E // Сдвиг окна на одну строку вверх (курсор остается на месте)

<CTRL> + Y  // Сдвиг окна на одну строку вниз (курсор остается на месте)

<CTRL> + L //  Автоматическое завершение целой строки с поиском в обратном направлении.

<CTRL> + K // Автоматическое завершение слова из файла, указанного в параметре 'dictionary'

<CTRL> + T // Автоматическое завершение слова из файла, указанного в параметре 'thesaurus'. Пример использования данной команды рассмотрен далее.

<CTRL> + I // Автоматическое завершение слова с поиском в текущем файле и всех подключаемых файлах.

<CTRL> + ] // Автоматическое завершение тэгов

<CTRL> + F // Автоматическое завершение имени файла


Особое внимание заслуживает комманда <CTRL> + T. Она представляет собой поиск в словаре. Рассмотрим пример использования этой команды. Допустим файл словаря содержит следующую строку:

великолепный замечательный прекрасный отличный превосходный

Если вы наберете великол и нажмете комбинацию <CTRL> + T , то будет вставлено слово великолепный. Последующие нажатия этой комбинации будут вставлять следующие слова соответственно: замечательный, прекрасный, отличный, превосходный.

Способов применения этой команды может быть множество, от подбора синонимов до организации удобной работы со словарем (при переводе).

6. Удаление, копирование, вставка – работа с регистрами
Не смотря на то, что команды автоматического завершения часто избавляют нас от необходимости копировать и вставлять текст, тем не менее необходимость таких операций остается. Копирование и удаление фрагментов текста выполняются в режиме VISUAL. Исключение составляю команды удаления целого слова или строки, так как в этом случае границы фрагмента очевидны исходя из положения курсора. Следует отметить, что в отличии от большинства текстовых редакторов, использующих системный буфер, VIM имеет обширный набор собственных буферов (регистров). Другими словами у вас есть возможность иметь одновременно скопированными несколько фрагментов текста. В том числе операции удаления, копируют удаленный фрагмент в специальный регистр.



Команда

Описание

VISUAL

ab // Выделить фрагмент ограниченный символами “(” и “)” включительно

ib // Выделить фрагмент ограниченный символами “(” и “)”

aB // Выделить фрагмент ограниченный символами “{” и “}” включительно

iB // Выделить фрагмент ограниченный символами “{” и “}”

ap // Выделить параграф

a[ // Выделить фрагмент ограниченный символами “[” и “]” включительно

i[ // Выделить фрагмент ограниченный символами “[” и “]”

a< // Выделить фрагмент ограниченный символами “<” и “>” включительно

i< // Выделить фрагмент ограниченный символами “<” и “>”

: // Выполнить ex- команду для выделенного фрагмента

["x] D // Удалить выделенные строки в регистр “х”

["x] Y // Скопировать выделенный фрагмент в регистр “х”

["x] p // Заменить выделенный фрагмент содержимым регистра “х”

u // Установить для выделенного фрагмента нижний регистр

U // Установить для выделенного фрагмента верхний регистр



NORMAL

["x] p // Вставить текст из регистра “х” после курсора

["x] P // Вставить текст из регистра “х” до курсора

["x] y // Копировать текущую строку в регистр “х”



INSERT

<CTRL> + R // Вставляет содержимое регистра. При нажатии этой комбинации в место вставки впечатывается символ кавычек и ожидается ввод идентификатора регистра. В качестве последнего могут выступать следующие символы: 0-9, a-z, ", %, #, *, +, :, ., -, =




По скольку при копировании и вставке фрагментов текста мы активно используем регистры, то давайте остановимся на них подробней. VIM поддерживает следующие виды регистров:

безымянный регистр ““;

10 нумерованных регистров от “0 до “9;

Регистр малого удаления “-;

26 именованных регистров от “a до “z или от “A до “Z;

4 регистра, доступных только для чтения: “:, “., “%, “#;

регистр выражения “=;

регистры выделения “* и “+:

регистр “Черная дыра” – “_;

последний шаблон поиска “/.

Безымянный регистр используется при всех операциях копирования или удаления, если только в качестве целевого регистра не указана “Черная дыра”. В последнем случае удаленный фрагмент не копируется ни в дин из регистров. Если при вставке текста не указан регистр-источник, то в качестве источника используется безымянный регистр. Если в качестве целевого регистра при копировании указать безымянный регистр, то запись осуществляется в регистр “0.

Нумерованные регистры заполняются скопированными или удаленными фрагментами текста. При этом регистр “0 содержит последний скопированный фрагмент, если не было указано целевого регистра. Регистр “1 содержит последний удаленный фрагмент, если только не было указано другого регистра и если удаленный фрагмент содержит более одной строки текста. При удалении фрагментов размером менее строки, он копируется в регистр “-. При каждом успешном удалении фрагмент из регистра “1 переносится в регистр “2, из “2 в “3 и так далее. Содержимое регистра “9 безвозвратно теряется.

Именованные регистры записываются только по прямому указанию пользователя. При этом если указывается строчная буква, то фрагмент будет перезаписан, а если заглавная, то фрагмент будет добавлен.

Назначение остальных регистров очевидно по названию и указано в таблице

Специальные регистры:

Символ

Описание

<“> // Безымянный регистр, содержащий последний удаленный или скопированный текст

<%> // Имя редактируемого файла

<#> // Альтернативное имя файла

<*> // Содержимое буфера обмена (X11 непосредственное выделение)

<+> // Содержимое буфера обмена

</> // Последний ключ поиска

<:> // Последняя команда

<.> // Последний вставленный текст

<-> // Последнее “короткое” удаление (меньше строки)

<=> // Регистр выражения – вас попросят ввести выражение, результат вычислений будет вставлен в текст.





7. Работа с несколькими файлами и "окнами"


Конечно VIM позволяет работать с несколькими файлами одновременно. Я не буду подробно описывать все механизмы связанные с этой темой, а рассмотрю только наиболее полезные и простые операции.

Каждый открытый файл может либо отображаться, либо быть скрытым. Мы пропустим описание скрытых файлов, так как чаще всего встречается ситуация, когда необходимо именно отображать несколько файлов. Для этого мы должны рабочее окно разделить на два. По умолчанию в новое окно грузится тот же файл. Это может быть полезно, если необходимо иметь визуальный доступ к нескольким частям одного и того же документа. Однако вы можите в одно из окон загрузить новый файл. Интересной особенностью является то, что рабочее окно может быть разделено по вертикали или по горизонтали.



Команда

Описание

NORMAL

:sp // Разделить текущее окно на два по горизонтали. В результате вы имеете два вида на один файл. Первоначальное окно делится пополам.

<CTRL> + W S

<CTRL> + W

<CTRL> + S

:vs // Разделить текущее окно на два по вертикали. В результате вы имеете два вида на один файл. Первоначальное окно делится пополам.

<CTRL> + W v

<CTRL> + W

<CTRL> + V

:new // Создает новое окно (горизонтальное разделение), в котором начинается редактирование пустого (нового) файла.

<CTRL> + W n

<CTRL> + W

<CTRL> + N

:vne // Создает новое окно (вертикальное разделение), в котором начинается редактирование пустого (нового) файла.

8. Поиск, замена
VIM имеет очень мощные средства для поиска и замены текста. Эти механизмы основаны на так называемых регулярных выражениях. Если читатель знаком с этой технологией, то мои объяснения будут излишни, если нет – то это тема для отдельной статьи. Рассмотри наиболее употребимые варианты.

Простой поиск осуществляется с помощью команды “/” или “?” в нормальном режиме для поиска вперед или назад по тексту соответственно. После символа команды необходимо указать шаблон для поиска. Для повторного поиска необходимо нажать соответствующую команду (без шаблона). Удобной особенностью поиска является автоматическая подсветка найденных слов.

Кроме этого, есть очень удобная функция поиска слова на которое указывает курсор. Для этого необходимо в нормальном режиме установит курсор на требуемое слов и нажать # или * для поиска назад или вперед соответственно.

Для замены дного фрагмента текста (шаблон) на другой (новый текст) необходимо использовать следующую форму записи команды:

[range]s/шаблон/новый текст/[i][g][c] // где [range] – указывает где именно необходимо осуществить операцию замены. Возможны следующие варианты этого параметра: % – весь текст, 1 – первая строка, . – текущая строка, $ – последняя строка, .,$ – от текущей строки и до конца файла, и так далее. Параметры в конце команды определяют ее поведение следующим образом: i – игнорировать регистр, g – заменять все слова в строке, иначе заменяется только первое найденное слово, c – подтверждать каждую замену.

Если вы вызвали команду замены из режима VISUAL, и опустили первый параметр, то замена будет осуществляться только в выделенной области.

9. Русские кодировки
Одной из проблем, с которой можно встретиться при редактировании документов, содержащих русский текст, является используемая кодировка. Для русского текста широко используются три основные кодировки (реально их больше, но остальные постепенно уходят в прошлое): Dos (альтернативная кодировка 866), Win (cp1251), Koi8-ru (Основная кодировка, используемая в семействе операционных систем Unix). Даже эти несколько разновидностей могут доставить значительно неудобствое в работе. Как вы уже догадались Vim поддерживает работу с различными кодировками. Более того, он поддерживает двухбайтную кодировку и различные направления письма. Хотя для нас это не играет особой роли.

Для поддержки различных кодировок необходимо добавить библиотеку iconv.dll (Для работы в Windows), которая распространяется отдельно. В современных дистрибутивах Linux все необходимое уже есть изначально.

За формат текстового документа отвечают два основных параметра: fileformat и fileencoding . Первый параметр определяет способ формирования строк в документе. Он может принимать следующие значения: dos (конец строки обозначается парой кодов <CR><NL>), unix (<NL>), mac (<CR>). Второй параметр определяет собственно кодировку. Она может принимать множество значений, но нас интересуют только несколько : koi8-r, koi8-u, 866, cp1251 и др.

Эти параметры можно установить для редактора глобально, при открытии файла, локально для буфера или для уже открытого файла. Как это все работает рассмотрим на примере. Допустим, у нас есть некий файл “dos.txt”. Он набран в MS Dos в соответствующей кодировке. Но мы этого не знаем и пытаемся открыть его на редактирование в ОС Linux. Для этого мы выполняем команду :e dos.txt. Файл открывается, и его формат распознан автоматически, о чем свидетельствует пометка [dos] в строке статуса, но кодировка к сожалению не распознана, в результате чего мы наблюдаем на экране абракадабру. Однако отобразить этот файл в нормальном виде не составит труда. Необходимо набрать команду :e ++enc=866, при этом русские буквы примут свой обычный вид, а строка статуса дополнится пометкой [converted]. Теперь мы можем работать с этим файлом без проблем. При сохранении его формат сохранится. Но если мы хотим преобразовать его в более удобный для нас формат, то достаточно набрать :set fenc=koi8-r и пометки в строке статуса исчезнут, а сохраненный файл будет в нашем выбранном формате и кодировке. Работа непосредственно с командами может показаться неудобной. И с этим можно согласиться, но если вы планируете часто выполнять подобные операции, то ничего не стоит добавить эти операции в графическое меню или назначить им горячие клавиши.



10. Макросы


VIM имеет очень мощные средства автоматизации работы. Для выполнения рутинных операций в текущем или группе файлов имеется встроенный язык. Этот язык достаточно функционален. Есть готовые решения создающие на базе VIM дневник с календарем или даже игру (Тетрис). Однако, описание встроенного языка выходит далеко за рамки данного труда и уж никак не относится к простым приемам редактирования. Этот раздел добавлен с единственной целью немного приоткрыть штору скрывающую внутреннюю мощь этого текстового редактора.

Есть и более простой способ для повторения простых действий – линейный алгоритм, без ветвлений. Этот так называемые “сложные повторения” или “записи”. Эти макросы записываются непосредственно в именованные регистры. Для начала записи необходимо в режиме NORMAL нажать “q” и имя того регистра, в который необходимо осуществить запись. Окончание записи осуществляется повторным нажатием “q”. Для повтора записанных действий в режиме NORMAL используется команда “@” + имя регистра, а в режиме INSERT - <CTRL>+R + имя регистра.

Есть еще один метод быстрой подстановки фиксированных слов (словосочетаний или даже целых выражений). Этот метод использует так называемые аббревиатуры. Для описания своей аббревиатуры необходимо выполнить команду :iabbrev за которой следует аббревиатура и ее расшифровка соответственно. Пример: :iabbrev M$ Microsoft. После выполнения этой команды, если вы введете M$ с последующим пробелом, то автоматически будет подставлена соответствующая расшифровка “Microsoft”.

11. Группировка текста
И на последок я оставил самый, на мой взгляд, вкусный кусок. Особенно он понравится программистам. Думаю вам случалось писать объемные программы с множеством функций. Хорошим стилем считается группировка этих функций по отдельным файлам (классам при использовании ООП). Однако и в каждом файле может оказаться значительное количество кода. Навигация по этому файлу может быть затруднена. Не смотря на то, что VIM и без того имеет команды, позволяющие быстро отыскать нужную функцию или ее описание, в него еще встроена возможность временно скрывать часть текста, оставляя тем самым заголовки функций на виду и убирая непосредственно реализацию. При необходимости каждый (или все) фрагмент может быть открыт, отредактирован и закрыт. Такой подход делает программу более обозримой и удобной для восприятия.

Группировка может быть осуществлена одним из следующих способов:

вручную;

по левому отступу, больший означает глубину вложенности;

по вычисляемому выражению, определяющему группировку;

в соответствии с подсветкой синтаксиса;

в соответствии с командой diff – скрываются одинаковые фрагменты текста;

По специальным маркерам в тексте.



Рассмотри только первый способ группировки. Группировки, созданные вручную теряются при закрытии файла. Чтобы их сохранить необходимо выполнить команду :mkview. Восстановление сохраненных группировок осуществляется с помощью команды :loadview. Другие команды для работы со сгруппированным текстом приведены в таблице:

Команда

Описание

VISUAL

zf // Группирует (скрывает) выделенный фрагмент текста

NORMAL

zfap // Скрывает параграф, содержащий курсор

zf // Создать маркеры группировки

zd // Удалить маркеры группировки

zE // Удаляет все группировки в текущем окне (действует на группировки, созданные вручную и с помощью маркеров)

zo // Открыть текущую группировку

zc // Скрыть (закрыть) текущую группировку

zO // Открыть текущую группировку (рекурсивно)

zC // Скрыть (закрыть) текущую группировку (рекурсивно)

zM // Скрыть все группировки

zR // Открыть все группировки





INSERT





12. Режим быстрой отладки
VIM поддерживает специальный режим работы ускоряющий цикл “редактирование – компиляция – редактирование”. Суть его заключается в том, что сообщения (ошибки и предостережения), генерируемые компилятором, сохраняются в файл и используются редактором, для быстрого перехода к месту возникновения ошибки. Используя этот режим вы получаете по сути удобную среду разработки не привязанную к конкретному языку и платформе. Для работы в режиме быстрой отладки могут быть полезны следующие команды:





Команда

Описание

NORMAL

:make // Запуск сборки проекта.

:cc [номер] // Отображение ошибки с указанным номером

:cn // Перейти к следующей ошибке

:cp // Перейти к предыдущей ошибке

:cr // Перейти к первой ошибке

:cla // Перейти к последней ошибке

:cq // Выйти из программы с возвратом кода ошибки

:cf [имя файла] // Загрузить указанный файл в качестве файла ошибок

:cl // Отобразить все ошибки

:copen // Открыть окно со списком ошибок

:cclose // Закрыть окно со списком ошибок





Важной деталью работы в этом режиме является распознание формата файла ошибок. Очевидно, что различные компиляторы генерируют их поразному. Более того, в некоторых из них, этот формат можно задавать или выбирать. Для работы с конкретным компилятором необходимо настроить систему разбора файла с ошибками. Делается это с помощью команды :compiler {название}. По сути, при выполнении этой команды запускается скрипт, который настраивает параметры VIM на работу с указанным компилятором. Эти параметры можно легко настроить и вручную или написать свой скрипт.

13. Параметры, которые полезно знать и настраивать
Установка параметров осуществляется командой :set. Она имеет следующие варианты исполнения:

:set //  показывает все опции, значения которых отличаются от их стандартных значений;

:set all //  показывает все опции, кроме терминальных;

:set termcap // показывает только терминальные опции;

:set {option}? //  показывает значение опции {option};

:set {option} – если {option} // логическая, то устанавливает ее в состояние “on”, иначе показывает значение;

:set no{option} // устанавливает опцию в состояние “off”

:set {option}! // инвестирует значение опции;

:set {option}& // устанавливает значение опции в ее стандартное значение;

:set {option}={value} // устанавливает значение опции равным {value}.



Параметр

Сокр.

Тип

Описание

autoindent

ai // триггер При начале новой строки отступ копируется с предыдущей

autowrite

aw // триггер Сохраняет содержимое файла, если он был изменен перед выполнением некоторых команд

backup

bk // триггер Создает резервную копию файла при перезаписи. Оставляет ее после успешного окончания записи. Если вы не хотите оставлять резервную копию после успешного завершения записи, то сбросьте значение этого параметра в “off” и установите параметр writebackup

backupcopy

bkc // строка Определяет метод создание резервной копии: “yes” - копирует существующий файл и перезаписывает старый; “no” - переименовывает существующий файл и создает новый, “auto” - выбирает наиболее оптимальный вариант.

binary

bin // триггер Эту опцию необходимо установить перед попыткой редактирования бинарных файлов

dictionary

dict // строка Список файлов, разделенных запятыми. По этим файла происходит поиск при авто-завершении ключевых слов (<CTRL>-X + <CTRL>-K).

display

dy // строка Изменяет способ отображение текста. Представляет собой список флагов разделенных запятыми: “lastline” - если последняя строка, отображаемая в окне, не может быть показана полностью, то видна ее часть, иначе она заменяется символами “@” ; “uhex” - непечатные символы отображаются в шестнадцатиричном виде как <xx>, вместо использования ^C и ~C.

errorfile

ef // строка Имя файла с ошибками в режиме быстрой отладки

errorformat

efm // строка Описание формата строки файла с ошибками, записанное в стиле scanf

fileencoding

fenc // строка Кодировку текущего файла

fileformat

ff // строка Формат текущего файла

foldclose

fcl // строка Если равно “all”, то группировки автоматически закрываются, когда курсор выходит за их пределы.

foldmethod

fdm // Строка Определяет метод группировки для текущего окна: “manual” - ручная группировка; “indent” - группируются строки с одинаковым отступом ; “expr” - уровень группировки определяется по вычисленному выражению; “marker” - группировка осуществляется в соответствии с маркерами; “syntax” - группируются элементы с подсветкой синтаксиса; “diff” - группируется текст, не содержащий изменений

ignorecase

ic // триггер Игнорировать регистр при поиске

makeef

mef // строка Имя файла ошибок, возникших при выполнении команды :make. Усли не указано, то используется автоматически сгенерированное имя.

makeprg

mp строка Программа, используемая при выполнении команды :make.

modeline

ml логич. Включает непосредственное включение строки конфигурации в редактируемый файл.

shiftwidth

sw // число Число пробелов, используемых при автоотступе.

showbreak

sbr // строка Символы, которыми обозначаются автоматически перенесенные строки

showmatch

sm // триггер Если установлено, то при вводе закрывающей скобки происходит быстрая подсветка соответствующей ей открывающей скобки.

tabstop 

ts // число Размер табуляции

textwidth

tw // число Максимальное число символов, которые могут быть введены в одну строчку. Если установить равным 0, то данная функция отключается.

thesaurus

tsr // строка Список файлов , по которым осуществляется поиск словарных статей. (<CTRL>+X + <CTRL>+T)

undolevels

ul  // число Максимальное число изменений, которые могут быть отменены

visualbell

vb // триггер Заменить звуковой сигнал визуальным

wrap // триггер Определяет отображение текста. Непосредственных изменений в открытый файл не вносится. Когда параметр установлен, то строки длиннее окна отображаются в следующих строчках и не обрезаются. Иначе видна только часть строки.

writebackup

wb // триггер При перезаписи файла, создается его временная копия, таким образом, ни при каких обстоятельствах не могут пострадать ваши данный. После успешной перезаписи резервная копия удаляется.



14. Заключение
Я очень надеюсь, что этот документ оказался вам полезен, и вы узнали из него что-то новое. Для людей, которые только познакомились с VIM хочу заметить, что перечисленные и описанные здесь возможности – это только вершина айсберга. Действительно, VIM таит в себе огромную мощь. На его основе программист может легко организовать удобную среду разработки. Несмотря на то, что в среде профессиональных программистов, особенно *nix – ориентированных, этот редактор высоко оценен, я хотел бы привести еще несколько доводов в его пользу. Дело в том, что общественное признание VIM еще выражается и в том, что такие ведущие, в своих областях, интегрированные среды разработки как MSVisualStudio и KDevelop имеют возможность интеграции с VIM. На мой взгляд, это достаточно серьезный довод!

Тем не менее этот документ далек от идеала, ему нехватает примеров, не освещены очень многие варианты применения VIM. Возможно в нем содержатся некоторые ошибки как грамматические так и смысловые. То это не готовый продукт, а только первая версия. Поэтому я надеюсь, что заинтересованные люди примут участие в редактировании и дополнении данного документа. Ваши замечания и благодарности :-) можите отсылать по адресу i_yalovoy@mail.ru.Записки программиста

Блог о программировании, а также электронике, радио, и всяком таком

Моя шпаргалка по работе в Vim

5 октября 2009

Самое главное — побороть боязнь белого листа. Я всегда говорю это себе, когда нужно начать работу над чем-то и не знаешь, как подступиться. Так что я решил не ломать голову над тем, о чем будет первая запись в этом блоге, а просто выложить небольшую шпаргалку по текстовому редактору Vim.

Шпаргалка эта уже не первый месяц хранится у меня в ~/txt/vim.txt. За это время я успел составить довольно объемный справочник по основным командам Vim. При желании вы можете начать свое обучение работе с Vim с этого поста.

Итак, вот она:

// Файл настройки: ~/.vimrc
// Можно редактировать файлы через сеть, например :e <scp|ftp|ftps>://user@host/path/to/the/file.txt
:Ex или :e ./ // файловый менеджер

== Основы ==
hjkl                    //  перемещение в разные стороны
i                       //  режим вставки
I                       //  добавление в начало строки
a                       //  режим добавления
A                       //  добавление в конец строки
o                       //  добавить строку сразу за текущей
O                       //  добавить строку перед текущей
R                       //  писать поверх имеющегося текста
u, :u[ndo]              //  отмена предыдущего действия (undo)
CTR-R, :red[o]          //  отмена отмены предыдущего действия (redo)
dd                      //  вырезать (удалить) строку
cc                      //  удалить и начать редактирование
yy                       // копировать строку
p                        // вставить из буфера обмена
<n>dd                    // удалить n строк
<n>yy                    // скопировать n строк
ESC                      // перейти в режим просмотра
DEL                      // удалить следующий символ
:<n>                     // перейти на строку #n
%                        // перейти к парной скобке
:e **/filename.c         // редактировать файл (с поиском по имени)
:w [fname]               // записать изменения
:wa                      // сохранить изменения во всех файлах
:q                       // выйти из редактора
:q!                      // выйти из редактора, не сохраняя изменения
:color <name>            // выбор цветовой схемы. цветвые схемы:
                            /usr/local/share/vim/vim72/colors/*.vim
:pwd                     // текущий каталог
:cd [path]               // перейти в другой каталог
:!команда                // выполнить команду - man, git, и так далее
                            стрелочками веерх и вниз можно автодополнять
                            команды и искать по истории
CTR+p или CTR+n          // автоматическое дополнение текста
                            (в режиме редактирования)
CTR+r,=,<expr>           // вставить выражение, например 5*2 - 3
                            (в режиме редактирования)
CTR+u, CTR+d             // Page Up / Page Down
CTR+y, CTR+e             // Перемотка вверх/вниз без движения курсора              

== Подсветка синтаксиса ==
:syntax on               // включить подсветку
:syntax off              // выключить подсветку (по умолчанию)

== Перенос строк ==
:set wrap                // разрешить word wrap (по умолчанию)
:set nowrap              // запретить word wrap

== Печать ==
:ha[rdcopy]                  // распечатать документ
:set printoptions=duplex:off // отключить двустороннюю печать

== Сворачивание ==
zc                       // свернуть блок
zo                       // развернуть блок
zM                       // закрыть все блоки
zR                       // открыть все блоки
za                       // инвертирование
zf                       // см :set foldmethod=manual
:set foldenable          // включить свoрачивание
:set foldmethod=syntax   // сворачивание на основе синтаксиса
:set foldmethod=indent   // сворачивание на основе отступов
:set foldmethod=manual   // выделяем участок с помощью v и говорим zf
:set foldmethod=marker   // сворачивание на основе маркеров в тексте
:set foldmarker=bigin,end // задаем маркеры начала и конца блока

== Маркеры ==
ma                       // установить локальный маркер a
mB                       // установить глобальный маркер B
`c                       // перейти к локальному маркеру c
`0                       // вернуться на позицию, на которой закончили
                           работу при закрытии vim
:marks                   // просмотр маркеров
set viminfo='1000,f1     // маркеры пишутся в ~/.viminfo, восстанавливаясь
                            при следующем запуске vim. маркер " хранит
                            последнюю позицию курсора в файле
== Сессии ==
mksession file.session   // сохранить текущую сессию
source file.session      // восстановить ранее сохраненную сессию

== Макросы ==
qa                       // записать макрос с именем a
q                        // в режиме записи макроса: закончить запись
@a                       // выполнить макрос с именем a
@@                       // повторить последний макрос

== Регистры ==
"ayy                     // скопировать строку в регистр a
"bdd                     // вырезать строку и поместить в регистр b
"С2d                     // вырезать три строки и дописать в конец
                            регистра C
:reg [name1][name2][...] // просмотреть содержимое регистров

== Выделение ==
v + hjkl                 // выделение текста
SHIFT + v                // выделить строку
CTR + v                  // выделение прямоугольника
p                        // вставить
y                        // копировать
d                        // удалить
gu                       // к нижнему регистру
gU                       // к верхнему регистру

== Отступы ==
[#]>                     // сдвинуть выделенное вправо
[#]<                     // сдвинуть выделенное влево
[#]>>                    // сдвинуть строку вправо
[#]<<                    // сдвинуть строку влево
set tabstop=#            // для табуляции используется # пробелов
set shiftwidth=#         // в командах отступа используется # пробелов
set [no]expandtab        // заменять ли табуляцию на соответствующее
                            число пробелов

== Поиск и замена в файле ==
/Выражение              // поиск выражения в файле
\cВыражение             // поиск без учета регистра
n                       // следующее совпадение
N                       // предыдущее совпадение
:%s/foo/bar/gi          // замена строк, см http://eax.me/regular-expr/

== Поиск по всему проекту ==
:vimgrep /EXPR/ **/*.c  // поиск по регулярному выражению
:copen                  // показать все найденные места
:close                  // скрыть все найденные места
:cn                     // переход к следующему результату
:cp                     // переход к предыдущему результату

== Нумерация строк ==
:set number             // включить нумерацию строк
:set nonumber           // отключить нумерацию строк

== Работа с вкладками (a.k.a табами) ==
:tabnew [fname]         // создать таб
:tabs                   // вывести список табов
:tabn                   // следующий таб
:tabp                   // предыдущий таб
<n>gt                   // перейти на таб #n
gt                      // следующий таб
gT                      // предыдущий таб
:tabm +1                // переместить таб вперед на одну позицию
:tabm -1                // переместить таб назад на одну позицию
:tabm 2                 // переместить таб на заданную позицию
                           (нумерация начинается с нуля)

== Работа с окнами ==
:split                  // горизонтальное разбиение
:vsplit                 // вертикальное разбиение
Ctr+W, затем
  с                     // закрыть окно
  +-                    // изменение высоты текущего окна
  <>                    // изменение ширины текущего окна
  =                     // установить равный размер окон
  hjkl или стрелочки    // перемещение между окнами

== Проверка орфографии ==
    mkdir -p ~/.vim/spell
    cd ~/.vim/spell
    wget http://ftp.vim.org/vim/runtime/spell/ru.koi8-r.sug
    wget http://ftp.vim.org/vim/runtime/spell/ru.koi8-r.spl
    wget http://ftp.vim.org/vim/runtime/spell/en.ascii.sug
    wget http://ftp.vim.org/vim/runtime/spell/en.ascii.spl

:set spell spelllang=ru      // включить проверку орфографии
:set spell spelllang=en 

:set nospell                    // выключить проверку орфографии
]s                              // следующее слово с ошибкой
[s                              // предыдущее слово с ошибкой
z=                              // замена слова на альтернативу из списка
zg                              // good word
zw                              // wrong word
zG                              // ignore word

== Работа с кодировкой ==
e ++enc=<имя кодировки>        // Редактирование файла в ??? кодировке
w ++enc=<имя кодировки>        // Сохранить файл в новой кодировке
set fileencodings=utf-8,koi8-r // Список автоматически определяемых
                                  кодировок в порядке убывания
                                  приоритета

== Другое ==
:set [no]wildmenu         // При авто-дополнении в командной строке над ней выводятся возможные варианты
:set list                 // Отображать табуляцию и переводы строк
q:                        // История команд
.                         // Повторение последней команды

Более подробный материал об использовании текстового редактора Vim вы найдете в книге Изучаем редакторы vi и Vim, 7-е издание. Книга доступна как в бумажном, так и в электронном формате.

На этом пока все. Думаю, я буду время от времени редактировать эту шпаргалку, так что следите за PS в конце следующих постов.

Дополнение: Также вас могут заинтересовать заметки Используем Vim в качестве IDE для Erlang и Небольшой обзор Sublime Text и шпаргалка по хоткеям.

Метки: Разработка.

Понравился пост? Узнайте, как можно поддержать развитие этого блога.

Также подпишитесь на RSS, ВКонтакте, Twitter или Telegram.

Коротко о себе

Меня зовут Александр, позывной любительского радио R2AUK. Днем я обычный программист, а ночью превращаюсь в радиолюбителя-коротковолновика. Здесь я пишу об интересующих меня вещах и временами — просто о жизни.

Вы можете следить за обновлениями этого блога с помощью RSS, ВКонтакте, Twitter или Telegram. Если вам нравится данный сайт, возможно, вы захотите поддержать его на Patreon.

Мой контактный e-mail — mail@eax.me. Если вы хотите мне написать, прошу предварительно ознакомиться с этим FAQ. Если у вас технический вопрос, просьба адресовать его на форум forum.devzen.ru.

 

Популярные заметки

Моя шпаргалка по работе с Git, 8290 просмотров за месяц

Моя шпаргалка по работе в Vim, 6797 просмотров за месяц

Краткая шпаргалка по сочетаниям клавиш в IntelliJ IDEA, 4404 просмотра за месяц

Начало работы с PostgreSQL, 3064 просмотра за месяц

Быстрое введение в Kubernetes, 2339 просмотров за месяц

Настройка фаервола с помощью iptables за пять минут, 2281 просмотр за месяц

Пишем под микроконтроллеры STM32 в Arduino IDE, 2207 просмотров за месяц

Шпаргалка по основным инструкциям ассемблера x86/x64, 2131 просмотр за месяц

Шпаргалка по использованию умных указателей в C++, 2124 просмотра за месяц

Как спроектировать схему базы данных, 1545 просмотров за месяц

Зачем нужен Docker и практика работы с ним, 1540 просмотров за месяц

Устанавливаем связку из Prometheus и Grafana, 1471 просмотр за месяц

Основы сборки проектов на С/C++ при помощи CMake, 1459 просмотров за месяц

Советы и примеры задач, которые помогут вам в освоении нового языка программирования, 1441 просмотр за месяц

Построение диаграмм на Python с помощью Matplotlib, 1384 просмотра за месяц

Потоковая репликация в PostgreSQL и пример фейловера, 1358 просмотров за месяц

Установки и настройка OpenVPN в Ubuntu Linux за 5 минут, 1272 просмотра за месяц

Перестаем бояться виртуализации при помощи KVM, 1141 просмотр за месяц

Памятка по virtualenv и изолированным проектам на Python, 1127 просмотров за месяц

Памятка по отладке при помощи GDB, 1111 просмотров за месяц

Копирование представленных на данном сайте материалов любыми способами не возбраняется.
Указание ссылки на оригинал приветствуется. © 2009–2020 Записки программиста

?

Knowledge

Search Posts

 

Настройка Vim

Posted on 26 апреля, 2019 | By mora | No comments

"НАСТРОЙКИ ВНЕШНЕГО ВИДА И БАЗОВЫЕ НАСТРОЙКИ РЕДАКТОРА

- set nocompatible " // отключить режим совместимости с классическим Vi 
- set scrolloff=3 " // сколько строк внизу и вверху экрана показывать при скроллинге "
- set background=dark " // установить цвет фона "цветовая схема по умолчанию (при вводе в режиме команд "по табуляции доступно автодополнение имён схем).- af, desert colorscheme desert set wrap " (no)wrap - динамический (не)перенос длинных строк 
- set linebreak " // переносить целые слова 
- set hidden " // не выгружать буфер когда переключаешься на другой 
- set mouse=a "// включает поддержку мыши при работе в терминале (без GUI) 
- set mousehide "  // скрывать мышь в режиме ввода текста 
- set showcmd " // показывать незавершенные команды в статусбаре (автодополнение ввода) 
- set mps+=<:> " // показывать совпадающие скобки для HTML-тегов 
- set showmatch " // показывать первую парную скобку после ввода второй 
- set autoread " // перечитывать изменённые файлы автоматически - set t_Co=256 " использовать больше цветов в терминале
- set confirm " // использовать диалоги вместо сообщений об ошибках "" Автоматически перечитывать конфигурацию VIM после сохранения autocmd! bufwritepost $MYVIMRC source $MYVIMRC "" Формат строки состояния " fileformat - формат файла (unix, dos); fileencoding - кодировка файла; " encoding - кодировка терминала; TYPE - тип файла, затем коды символа под курсором; " позиция курсора (строка, символ в строке); процент прочитанного в файле; " кол-во строк в файле; 
- set statusline=%F%m%r%h%w\ [FF,FE,TE=%{&fileformat},%{&fileencoding},%{&encoding}\]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L] "// Изменяет шрифт строки статуса (делает его не жирным) hi StatusLine gui=reverse cterm=reverse 
- set laststatus=2 " // всегда показывать строку состояния 
- set noruler "// Отключить линейку "" Подсвечивать табы и пробелы в конце строки 
- set list " // включить подсветку - set listchars=tab:>-,trail:- " установить символы, которыми будет осуществляться подсветка "Проблема красного на красном при spellchecking-е решается такой строкой в .vimrc highlight SpellBad ctermfg=Black ctermbg=Red au BufWinLeave *.* silent mkview " при закрытии файла сохранить 'вид' au BufWinEnter *.* silent loadview " при открытии - восстановить сохранённый set backspace=indent,eol,start " backspace обрабатывает отступы, концы строк set sessionoptions=curdir,buffers,tabpages " опции сессий - перейти в текущую директорию, использовать буферы и табы set noswapfile " не использовать своп-файл (в него скидываются открытые буферы) 
- set browsedir=current 
- set visualbell " // вместо писка бипером мигать курсором при ошибках ввода 
- set clipboard=unnamed " // во избежание лишней путаницы использовать системный буфер обмена вместо буфера Vim 
- set backup " // включить сохранение резервных копий autocmd! bufwritepre * call BackupDir() " сделаем резервную копию перед записью буфера на диск 
- set title " // показывать имя буфера в заголовке терминала
- set history=128 " // хранить больше истории команд 
- set undolevels=2048 " // хранить историю изменений числом N set whichwrap=b,<,>,[,],l,h " перемещать курсор на следующую строку при нажатии на клавиши вправо-влево и пр. "
- set virtualedit=all " // позволяет курсору выходить за пределы строки let c_syntax_for_h="" " необходимо установить для того, чтобы *.h файлам присваивался тип c, а не cpp " При вставке фрагмента сохраняет отступ 
- set pastetoggle= "// подсвечивает все слова, которые совпадают со словом под курсором. autocmd CursorMoved * silent! exe printf("match Search /\\<%s\\>/", expand('<cword>'))

 "НАСТРОЙКИ ПЕРЕМЕННЫХ ОКРУЖЕНИЯ if has('win32') let $VIMRUNTIME = $HOME.'\Programs\Vim\vim72' source $VIMRUNTIME/mswin.vim else let $VIMRUNTIME = $HOME.'/.vim' endif " запуск плагина NeoBundle if has('vim_starting') set runtimepath+=$VIMRUNTIME/bundle/neobundle.vim/ endif call neobundle#rc(expand("$VIMRUNTIME/bundle/")) NeoBundleFetch 'Shougo/neobundle.vim' "ПЛАГИНЫ "Для отключения - закомментировать строку "Примеры подключения разных типов репозиториев см. на "http://github.com/Shougo/neobundle.vim " "Репозитории на github NeoBundle 'Shougo/vimproc' NeoBundle 'Shougo/unite.vim' "Репозитории vim-скриптов "NeoBundle 'L9' "Проверка установки/подключения плагинов NeoBundleCheck

 "НАСТРОЙКИ ПОИСКА ТЕКСТА В ОТКРЫТЫХ ФАЙЛАХ 
- set ignorecase " ics - // поиск без учёта регистра символов 
- set smartcase " - // если искомое выражения содержит символы в верхнем регистре - ищет с учётом регистра, иначе - без учёта 
- set nohlsearch " // (не)подсветка результатов поиска (после того, как поиск закончен и закрыт) 
- set incsearch " // поиск фрагмента по мере его набора " поиск выделенного текста (начинать искать фрагмент при его выделении) vnoremap <silent>* <ESC>:call VisualSearch()<CR>/<C-R>/<CR> vnoremap <silent># <ESC>:call VisualSearch()<CR>?<C-R>/<CR> 

"НАСТРОЙКИ СВОРАЧИВАНИЯ БЛОКОВ ТЕКСТА (фолдинг) 
- set foldenable " // включить фолдинг "
- set foldmethod=syntax " // определять блоки на основе синтаксиса файла 
- set foldmethod=indent " // определять блоки на основе отступов 
- set foldcolumn=3 " // показать полосу для управления сворачиванием 
- set foldlevel=1 " // Первый уровень вложенности открыт, остальные закрыты 
- set foldopen=all " // автоматическое открытие сверток при заходе в них 
- set tags=tags\ $VIMRUNTIME/systags " // искать теги в текущй директории и в указанной (теги генерируются ctags)

 "НАСТРОЙКИ РАБОТЫ С ФАЙЛАМИ "Кодировка редактора (терминала) по умолчанию (при создании все файлы приводятся к этой кодировке)
- if has('win32') set encoding=cp1251 else set encoding=utf-8
- set termencoding=utf-8 endif " // формат файла по умолчанию (влияет на окончания строк) - будет перебираться в указанном порядке 
- set fileformat=unix " // варианты кодировки файла по умолчанию (все файлы по умолчанию сохраняются в этой кодировке) 

Команда	Описание
q	// Выход
q!	// Выйти без сохранения изменений, т.е. отменить изменения и выйти из файла
r fileName	// Чтение данных из файла с именем fileName
w	// сохранить файл и продолжить редактирование
wq	// Записать и выйти (сохранить и выйти)
x // То же, что и команда wq, т.е. запись и выход (сохранение и выход)
w fileName	// Запись в файл с именем fileName (сохранить как)
w! fileName	// Перезаписать в файл с именем fileName (сохранить как принудительно)


:e *part_of_file_name.txt // поиск файла в директории
:e *part_*.txt // поиск файла в директории

e ++enc=utf-8   // Редактирование файла в utf-8 кодировке

:set number     // включить нумерацию строк
:set nonumber   // отключить нумерацию строк

/int (n - move down, N - move up) // поиск выражения в файле


:color pablo // изменить цветовую схему
:color delek // изменить цветовую схему
:color shine // изменить цветовую схему(светлая тема)


:e c:\ // просмотр каталога

:vs file_2.txt        -// добавляем файл для сравнения
:diffthis (in origin file_1.txt) - // включаем режим в исходном файле 
:diffthis (in file_2.txt) - // включаем режим в добавленном файле 
:diffoff - // отключает режим сравнения в каждой панели


Многооконный режим редактирования файлов в Vim	[исправить]

vim -o /etc/passwd /etc/hosts // Открытие двух файлов в разных окнах vim. С горизонтальной разбивкой окон на экране: 
vim -o /etc/passwd -o /etc/group /etc/hosts // Открытие трех файлов в разных окнах vim. С горизонтальной разбивкой окон на экране

С вертикальной разбивкой окон на экране:
vim -O /etc/passwd /etc/hosts // Открытие двух файлов в разных окнах vim. с вертикальной разбивкой окон на экране
vim -O /etc/passwd -O /etc/group /etc/hosts // Открытие двух файлов в разных окнах vim. с вертикальной разбивкой окон на экране

Наглядный просмотр отличий нескольких файлов
   vim -d файл1 файл2
   vim -d файл1 -d файл2 файл3

Команды переключения между окнами:
"CTRL-w w" - // быстрое переключение на следующее окно
"CTRL-w влево" - // активация левого окна
"CTRL-w вправо" - // активация правого окна
"CTRL-w вверх" - // активация верхнего окна
"CTRL-w вниз" - // активация нижнего окна
"CTRL-w n" - // создать новое окно (":new файл" - открыть заданный файл)
"CTRL-w q" - // закрыть текущее окно 
   (":qall" - // закрыть все окна разом, ":qall!" - без сохранения, ":write" - записать данные во всех  окнах)
"CTRL-w s" - // разбить текущее окно на 2 части для синхронного редактирования разных частей
   (в каждом окне будет содержимое одного и того же файла).
"CTRL-w +", "CTRL-w -" - // увеличение или уменьшение текущего размера окна
"ESC 5 CTRL-w -", "ESC 5 CTRL-w +" - изменение размера сразу на 5 строк/столбцов
"CTRL-w h" - // переместить окно влево
"CTRL-w j" - // переместить окно ниже
"CTRL-w k" - // переместить окно выше
"CTRL-w l" - // переместить окно вправо
"CTRL-w t" - // переместить окно на самый верх
"CTRL-w b" - // переместить окно в самый низ

Навигация по ФС
:e .	// Открыть встроенный файл-менеджер
:Sex	// Разбить окно и открыть встроенный файл менеджер
:browse e	// Графический файл-менеджер
:ls	// Список буферов
:cd ..	// Перейти в родительскую директорию
:args	// Список открытых файлов
:args *.php	// Открыть все файлы с расширением *.php
:grep expression *.php	// Показать список файлов с расширением php, содержащих в имени expression
gf	// Открыть файл с именем, равным слову, находящемуся под курсором


<Enter>	// в файловом менеджере открытие файла Использует текущее окно.
o	// в файловом менеджере открытие файла Открывает файл в новом окне.

Поиск файла
#include "inits.h" ~
и хотите посмотреть, что находится в этом файле «inits.h». Подведите курсор к имени файла и введите команду:

gf
Vim найдёт файл и откроет его для редактирования.

А что, если файл находится не в текущем каталоге? Тогда Vim будет использовать опцию ‘path’ для определения пути поиска. Значением этой опции является список каталогов, в которых нужно искать ваши файлы.

Предположим, ваши заголовочные файлы лежат в каталоге «c:/prog/include». Следующая команда позволит добавить этот каталог к опции ‘path’:

:set path+=c:/prog/include
Этот каталог представляет собой абсолютный путь. Независимо от того, где вы находитесь, он всегда будет ссылаться на одно и то же место. А что, если вы храните заголовочные файлы в каталоге внутри каталога с файлами исходных текстов программ? Тогда можно указать относительный путь. Он должен начинаться с точки:

:set path+=./proto

Если вы знаете имя файла, но оно не встречается в файле, то вы можете набрать его в командной строке:

:find inits.h

СПИСОК БУФЕРОВ
Посмотреть список буферов можно при помощи команды:

:buffers // Посмотреть список буферов
То же самое можно сделать и с помощью другой команды, которую гораздо быстрее набирать, но её имя не так очевидно передаёт смысл:

:ls // Посмотреть список буферов
Вывод команды может выглядеть примерно так:

1 #h   "help.txt"               строка 62 ~
2 %l+  "usr_21.txt"             строка 1 ~
3      "usr_toc.txt"            строка 1 ~
В первой колонке показан номер буфера. Номер можно использовать для перехода к редактированию буфера без необходимости вводить имя файла, см. об этом ниже.

После номера следует набор флагов, затем имя файла, и номер строки, на которой в последний раз находился курсор в этом буфере.

Флаги у буфера бывают следующие (слева направо):

u	Буфер не входит в список |буфер_вне_списка|.
 %	Текущий буфер.
  #	Соседний буфер.
   l	Буфер загружен и показан.
    h	Буфер загружен, но является скрытым.
     =	Буфер только для чтения.
      —	Буфер неизменяемый, опция ‘modifiable’ выключена.
       +	Буфер был изменён.
РЕДАКТИРОВАНИЕ БУФЕРА
Перейти к редактированию буфера можно по номеру. Это помогает избежать набора имени файла:

:buffer 2 // Перейти к редактированию буфера
Однако, единственный способ узнать номер буфера — это посмотреть список буферов. Вместо этого можно использовать часть имени, например:

:buffer help
Vim попытается найти наиболее удачное соответствие для введённого имени. В том случае, если найдено только одно соответствие, например «help.txt», будет использован этот буфер.

Для открытия буфера в новом окне:

:sbuffer 3
С этой командой также можно использовать имя (или часть имени).

ИСПОЛЬЗОВАНИЕ СПИСКА БУФЕРОВ
Перемещаться по списку буферов можно при помощи следующих команд:

:bnext       // переход к следующему буферу
:bprevious	// переход к предыдущему буферу           
:bfirst	// переход к первому буферу
:blast	// переход к последнему буферу
Чтобы удалить буфер из списка, пользуйтесь командой:

:bdelete 3 // удалить буфер из списка
Эта команда также работает с именами.

Если вы удаляете активный буфер, то окно, в котором он показан, будет закрыто. Если это было последнее окно, то Vim найдёт другой буфер для редактирования, потому что редактор устроен таким образом, что в нём что-то должно редактироваться.

Замечание: Даже после удаления буфера по команде «:bdelete», Vim продолжает о нём помнить. Говоря точнее, при удалении буфер помещается «вне списка» и не показывается по команде «:buffers». Тем не менее, он будет показан по команде «:buffers!» (с соответствующим флагом). Чтобы заставить Vim забыть о буфере начисто, используйте команду «:bwipe». Обратите также внимание на опцию ‘buflisted’.



ля замены дного фрагмента текста (шаблон) на другой (новый текст) необходимо использовать следующую форму записи команды:

[range]s/шаблон/новый текст/[i][g][c] //поиск и замена текста

поиск и замена в визуальном режиме
1. 1G Перейти в начало документа
2. /идиот Найти первое вхождение слова "идиот"
3. cwменеджер Заменить слово (cw) на менеджер
4. <esc> вернуться в визуал режим 
5. n перейти к следующему слову


:%s/\<идиот\>/менеджер/gc // поиск и замена в режиме строки
где:
идиот - искомое слово
менеджер - замена
g - меняет каждое вхождение
c - подтверждение каждой замены

файловый менеджер
% - добавляет новый файл в текущую директорию
x - открывает файл в текстовом редакторе



"*yy // копируем в буфер в виновс
"*p // вставка из регистра в визуальном режиме


:echo 3 + 3 // калькулятор




перемещение по текту

Перемещение по тексту:

h	// Влево
l	// Вправо
j	// Вниз
k	// Вверх
w	// Вперед на первую букву слова
e	// Вперед на последнюю букву слова
b	// Назад на первую букву слова
ge	// Назад на последнюю букву слова
W	То, же, что и w, но словом считается то, что отделено пустыми символами
E	То, же, что и e, но словом считается то, что отделено пустыми символами
B	То, же, что и b, но словом считается то, что отделено пустыми символами
gE	То, же, что и ge, но словом считается то, что отделено пустыми символами
^	// На первый непустой символ строки
$, End	// На конец строки
0 (ноль), Home	// На начало строки
(	// На первую точку слева от курсора (если она есть, в противном случае на начало абзаца)
)	// На первую точку справа от курсора (если она есть, в противном случае на конец абзаца)
{	// На абзац назад до пустой строки
}	// На абзац вперед до пустой строки

gk	// На одну экранную строку вверх.
f#	// Поиск вперед в строке символа # и установка курсора на него
F#	// Поиск назад в строке символа # и установка курсора на него
t#	// Поиск вперед в строке символа # и установка курсора после него
T#	// Поиск назад в строке символа # и установка курсора после него
;	// Повтор поиска вперед символа, найденного при помощи f/t/F/T
,	// Повтор поиска назад символа, найденного при помощи f/t/F/T
%	// Перемещение курсора на скобку, парную той, на которой находится курсор. Парные символы можно задать при помощи команды :set matchpairs
:#	// Перемещение курсора на строку #
#G	// Перемещение курсора на строку #, аналогично :#
gg	// Перемещение курсора в начало
G	// Перемещение курсора в конец
#%	// Перемещение курсора на # процентов от начала
H	// Перемещение курсора на начало видимой части текста
M	// Перемещение курсора на середину видимой части текста
L	// Перемещение курсора на конец видимой части текста
Control+u	// На полэкрана вверх
Control+d	// На полэкрана вниз
Control+y	// На одну строку вверх. Курсор при этом не перемещается
Control+e	// На одну строку вниз. Курсор при этом не перемещается
Control+b	// На один экран минус 2 строки вверх
Control+f	// На одну экран минус 2 строки вниз
zt	// Прокрутка текста так, чтобы курсор оказался вверху экрана
zz	// Прокрутка текста так, чтобы курсор оказался в середине экрана
zb	// Прокрутка текста так, чтобы курсор оказался внизу экрана
В обычном режиме:

<<	// Сдвинуть строку влево (табуляция)
>>	// Сдвинуть строку вправо (табуляция)
Режим выделения:

v	// Войти в режим выделения символов
V	// Войти в режим выделения строк
Control+Shift+v	// Войти в режим выделения прямоугольного блока текста
gv	// Выделяет текст, который был выделен предыдущей командой выделения
o	// Перемещение курсора в области блочного выделения для изменения размера влево
O	// Перемещение курсора в области блочного выделения для изменения размера вправо
I	// Включить вставку символов в блочном выделении. После нажатия I набираются символы, а по окончании нажимаете Escape. Все набранные символы будут вставлены в каждую строку
с	// Аналогично I, но перед вставкой символов удаляет всё, что было выделено блоком
с	// Аналогично I, но перед вставкой символов удаляет всё от левого края выделения до конца строки
u	// Изменить регистр выделенных символов на нижний
U	// Изменить регистр выделенных символов на верхний
~	// Изменить регистр выделенных символов на противоположный
J	// Объединить все строки, находящиеся в области выделения
r	// Заменить все символы на введенный после r, например rx заменит все символы в области выделения на x
<	// Сдвинуть выделенный блок влево (табуляция)
>	// Сдвинуть выделенный блок вправо (табуляция)
